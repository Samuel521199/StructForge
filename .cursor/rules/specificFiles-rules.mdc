---
alwaysApply: false
---

# StructForge 项目特定文件规则

> 这些规则针对特定文件类型、目录或路径应用，提供针对性的开发指导。

## 1. 前端文件规则

### 1.1 Vue 组件文件（*.vue）

**适用路径**: `frontend/src/views/**/*.vue`, `frontend/src/components/**/*.vue`

#### 1.1.1 前端组件使用规范

**强制要求**：所有前端页面必须使用通用组件库中的组件，禁止直接使用 Element Plus 组件。

**核心原则**（必须严格遵守）：
1. **优先使用通用组件**: 所有页面开发时，必须优先使用 `@/components/common/base` 中的通用组件
   - 在创建新页面时，首先检查通用组件库是否已有所需组件
   - 如果已有组件，必须使用通用组件，不得直接使用 Element Plus 组件
   
2. **缺失组件扩展**: 如果通用组件库中没有所需的组件，应在通用组件库中添加该组件后再使用
   - **禁止**：在页面中直接使用 Element Plus 组件来替代缺失的通用组件
   - **必须**：先在 `@/components/common/base/` 目录下创建新组件（参考现有组件结构）
   - **必须**：在 `base/index.ts` 中导出新组件
   - **然后**：在页面中使用新创建的通用组件
   
3. **复杂组件组合（预制组件模式）**: 对于复杂的业务组件，应通过组合多个基础组件（类似 Unity 预制物体的方式）创建预制组件，放在 `@/components/common/business/` 或相应的业务组件目录中
   - **禁止**：在页面中直接组合多个基础组件实现复杂功能
   - **必须**：将常用的组件组合封装为业务组件（预制组件）
   - **优势**：提高代码复用性、可维护性，便于未来可视化编辑器使用
   - **位置**：预制组件放在 `@/components/common/business/` 目录中

**组件层级结构**：
```
components/
├── common/                    # 通用组件（所有页面共享）
│   ├── base/                  # 基础组件（封装 Element Plus）
│   │   ├── Button/            # 按钮组件
│   │   ├── Input/             # 输入框组件
│   │   ├── Form/              # 表单组件
│   │   └── ...                # 其他基础组件
│   ├── business/              # 业务组件（组合基础组件）
│   │   ├── SearchBar/         # 搜索栏（组合 Input + Button）
│   │   ├── ActionBar/         # 操作栏（组合多个 Button）
│   │   └── ...                # 其他业务组件
│   └── effects/               # 效果组件（特殊视觉效果）
├── workflow/                  # 工作流相关组件
└── layout/                    # 布局组件
```

**使用规范**：

1. **基础组件使用**：
   ```vue
   <!-- ✅ 正确：使用通用组件 -->
   <template>
     <Form :model="form" :rules="rules">
       <FormItem label="用户名" prop="username">
         <Input v-model="form.username" />
       </FormItem>
       <FormItem>
         <Button type="primary">提交</Button>
       </FormItem>
     </Form>
   </template>
   
   <script setup lang="ts">
   import { Form, FormItem, Input, Button } from '@/components/common/base'
   </script>
   
   <!-- ❌ 错误：直接使用 Element Plus -->
   <template>
     <el-form>
       <el-form-item>
         <el-input />
       </el-form-item>
     </el-form>
   </template>
   ```

2. **缺失组件扩展流程**：
   - 步骤1: 检查 `@/components/common/base/` 中是否已有该组件
   - 步骤2: 如果不存在，在 `base/` 目录下创建新组件（参考现有组件结构）
   - 步骤3: 在 `base/index.ts` 中导出新组件
   - 步骤4: 在页面中使用新创建的组件

3. **复杂组件组合（预制组件）**：
   ```vue
   <!-- 示例：创建一个用户搜索栏预制组件 -->
   <!-- components/common/business/UserSearchBar/UserSearchBar.vue -->
   <template>
     <div class="user-search-bar">
       <Input 
         v-model="searchText" 
         placeholder="搜索用户..."
         :prefix-icon="Search"
       />
       <Button type="primary" @click="handleSearch">搜索</Button>
       <Button @click="handleReset">重置</Button>
     </div>
   </template>
   
   <script setup lang="ts">
   import { Input, Button } from '@/components/common/base'
   import { Search } from '@element-plus/icons-vue'
   // ... 业务逻辑
   </script>
   ```

4. **组件创建规范**：
   - 每个组件必须包含：
     - `ComponentName.vue`: 组件实现
     - `types.ts`: TypeScript 类型定义
     - `index.ts`: 导出文件
     - `README.md`: 组件文档（推荐）
   - 组件必须封装 Element Plus 组件，而不是直接暴露
   - 组件必须提供完整的 TypeScript 类型支持

**禁止事项**：
- ❌ **禁止直接使用 Element Plus 组件**: 禁止在页面中直接使用 `el-*` 标签
- ❌ **禁止直接导入 Element Plus 组件**: 禁止 `import { ElButton } from 'element-plus'`
- ❌ **禁止在页面中组合基础组件**: 复杂组合应在业务组件目录中创建预制组件
- ❌ **禁止跳过通用组件库**: 不得绕过通用组件库直接使用第三方组件
- ❌ **禁止在页面中创建缺失组件**: 如果通用组件库中缺少某个组件，必须在通用组件库中添加后再使用，禁止在页面中临时使用 Element Plus 组件替代

**推荐做法**：
- ✅ 新页面开发时，先查看通用组件库是否有所需组件
- ✅ 创建新组件时，参考现有组件的结构和命名规范
- ✅ 复杂业务逻辑封装为业务组件，提高复用性
- ✅ 保持组件 API 的一致性，便于后续维护

**组件迁移**：
- 现有页面如果直接使用了 Element Plus 组件，应逐步迁移到通用组件
- 迁移时参考 `frontend/src/components/common/base/MIGRATION_CHECKLIST.md`
- 迁移完成后，确保所有功能正常，样式保持一致

#### 1.1.2 通用效果组件规范

**适用路径**: `frontend/src/components/common/effects/**/*.vue`

**强制要求**：所有特殊视觉效果组件（如动画、粒子效果、背景特效等）必须放在 `frontend/src/components/common/effects/` 目录下。

**目录结构**：
```
components/common/effects/
├── CodeRain/              # 代码雨效果
│   ├── CodeRain.vue       # 组件实现
│   ├── types.ts           # 类型定义
│   ├── index.ts           # 导出文件
│   └── README.md          # 组件文档（推荐）
├── ParticleEffect/        # 粒子效果（示例）
│   └── ...
├── index.ts               # 统一导出
└── README.md              # 效果组件库说明
```

**命名规范**：
- 目录名：PascalCase，描述性名称（如 `CodeRain`, `ParticleEffect`）
- 组件文件名：与目录名相同，使用 `.vue` 扩展名
- 导出名：与目录名相同

**文件要求**：
- 每个效果组件必须包含：
  - `EffectName.vue`: 组件实现（必需）
  - `types.ts`: TypeScript 类型定义（必需）
  - `index.ts`: 导出文件（必需）
  - `README.md`: 组件文档（推荐）

**导出规范**：
- `types.ts` 应包含 `EffectNameProps` 和 `EffectNameEmits` 接口
- `index.ts` 应导出组件和类型：`export { default as EffectName } from './EffectName.vue'`
- `effects/index.ts` 应统一导出所有效果组件

**设计原则**：
- 性能优先：使用 Canvas 或 WebGL 实现高性能动画
- 可配置：提供丰富的配置选项，支持自定义
- 响应式：自动适应容器大小变化
- 资源管理：正确清理定时器、事件监听器等资源
- 无障碍：考虑可访问性，提供禁用选项

**禁止事项**：
- ❌ 禁止将效果组件放在 `components/common/effects/` 以外的位置
- ❌ 禁止在业务组件目录中直接实现特殊视觉效果
- ❌ 禁止在页面组件中直接实现复杂动画效果（应封装为效果组件）

### 1.2 TypeScript 文件（*.ts, *.tsx）

**适用路径**: `frontend/src/**/*.ts`, `frontend/src/**/*.tsx`

#### 1.2.1 TypeScript代码组织

- 使用Composition API，避免Options API
- 公共组件放在 `components/common/`
- 业务组件放在对应的功能目录
- 组合函数（Composables）放在 `composables/`
- API接口统一放在 `api/` 目录
- 工具函数放在 `utils/` 目录

#### 1.2.2 代码注释规范

**TypeScript代码**: 使用JSDoc格式

```typescript
/**
 * 获取用户信息
 * @param userId - 用户ID
 * @returns 用户信息
 */
async function getUser(userId: string): Promise<User> {
    // ...
}
```

## 2. 后端文件规则

### 2.1 Go 文件（*.go）

**适用路径**: `backend/**/*.go`

#### 2.1.1 Go代码组织

- 遵循Kratos框架的目录结构
- 业务逻辑放在 `biz` 层
- 数据访问放在 `data` 层
- 服务接口放在 `service` 层
- 公共代码放在 `common/` 目录

#### 2.1.2 代码注释规范

**Go代码**: 使用标准注释格式

```go
// GetUser 根据用户ID获取用户信息
// ctx: 上下文
// userID: 用户ID
// 返回: 用户信息和错误
func GetUser(ctx context.Context, userID string) (*User, error) {
    // ...
}
```

### 2.2 Protobuf 文件（*.proto）

**适用路径**: `backend/api/**/*.proto`

#### 2.2.1 API定义规范

- API定义在 `backend/api/service-name/v1/` 目录
- 文件命名: `service-name.proto`
- 使用标准的 Protobuf 语法
- 遵循 gRPC 最佳实践

### 2.3 配置文件（*.yaml, *.yml, *.json）

**适用路径**: `backend/configs/**/*.yaml`, `backend/configs/**/*.yml`, `backend/configs/**/*.json`

#### 2.3.1 配置规范

- 配置文件放在 `backend/configs/{environment}/` 目录
- 环境区分: `local`, `dev`, `staging`, `prod`
- 使用 YAML 格式（推荐）或 JSON 格式
- 敏感信息使用环境变量，不要硬编码在配置文件中

## 3. 数据库相关文件

### 3.1 数据库迁移文件（*.sql）

**适用路径**: `backend/deploy/migrations/**/*.sql`, `backend/script/migrations/**/*.sql`

#### 3.1.1 数据库迁移规范

- 迁移文件放在 `backend/deploy/migrations/` 或 `backend/script/migrations/` 目录
- 文件命名: `{序号}_{描述}.sql`
- 示例: `001_init_users.sql`, `002_init_workflows.sql`
- 使用事务确保迁移的原子性

### 3.2 数据库设计规范

- **表名**: snake_case，复数形式
  - 示例: `users`, `workflows`, `workflow_executions`
- **字段名**: snake_case
  - 示例: `user_id`, `workflow_name`, `created_at`
- **索引名**: `idx_表名_字段名`
  - 示例: `idx_users_email`, `idx_workflows_user_id`

## 4. 特定服务目录规则

### 4.1 AI模型适配器（backend/apps/ai/internal/adapters/**/*.go）

**适用路径**: `backend/apps/ai/internal/adapters/**/*.go`

#### 4.1.1 AI模型接入规范

所有AI模型必须实现统一的接口：

```go
type AIModel interface {
    // 模型调用
    Call(ctx context.Context, request *ModelRequest) (*ModelResponse, error)
    // 获取模型配置
    GetConfig() *ModelConfig
    // 健康检查
    HealthCheck(ctx context.Context) error
}
```

#### 4.1.2 适配器实现规范

- 每个适配器必须实现 `ModelAdapter` 接口
- 适配器放在 `backend/apps/ai/internal/adapters/{model-name}/` 目录
- 适配器文件命名: `adapter.go`
- 适配器配置通过环境变量或配置文件管理

### 4.2 节点实现（backend/apps/node/internal/nodes/**/*.go）

**适用路径**: `backend/apps/node/internal/nodes/**/*.go`

#### 4.2.1 节点执行流程

1. 参数验证（必填参数检查、参数类型验证、参数值范围检查）
2. 前置处理（输入数据转换、上下文准备、依赖检查）
3. 节点执行（调用节点执行器、超时控制、错误捕获）
4. 后置处理（结果验证、数据转换、日志记录）
5. 结果传递（序列化输出、传递给下游节点、更新执行上下文）

#### 4.2.2 节点类型分类

- **触发节点**: Webhook, Timer, Manual, Event
- **AI节点**: TextGeneration, ImageGeneration, CodeGeneration, DataAnalysis
- **数据处理节点**: Transform, Filter, Aggregate, Sort
- **集成节点**: HTTP, Database, File, Email
- **控制节点**: Condition, Loop, Parallel, Delay
- **工具节点**: CodeExecutor, Script, ExternalTool

### 4.3 工作流执行引擎（backend/apps/workflow/**/*.go）

**适用路径**: `backend/apps/workflow/**/*.go`

#### 4.3.1 执行模式

- **同步执行**: 适用于简单、快速的工作流（< 30秒），直接返回结果
- **异步执行**: 适用于复杂、耗时的任务，返回任务ID，通过WebSocket推送进度

## 5. 文档文件规则

### 5.1 Markdown 文档（*.md）

**适用路径**: `docs/**/*.md`, `**/README.md`, `**/*.md`

#### 5.1.1 文档系统规范

- **API文档**: OpenAPI 3.0 + Swagger UI（集成到API Gateway）
- **节点说明**: 数据库存储 + API提供（集成到节点服务）
- **工作流说明**: Markdown文件 + API提供（集成到工作流服务）
- **独立文档站**: VitePress（可选，用于对外文档）

#### 5.1.2 文档更新要求

- 每次API变更必须同步更新文档
- 新增或修改节点时必须更新文档
- 重要功能变更时更新相关文档

---

**最后更新**: 2025-11-20  
**版本**: v1.0

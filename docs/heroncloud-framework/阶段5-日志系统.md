# é˜¶æ®µ5ï¼šæ—¥å¿—ç³»ç»Ÿ

## ğŸ“š å­¦ä¹ ç›®æ ‡
- ç†è§£æ—¥å¿—ç³»ç»Ÿçš„é‡è¦æ€§
- æŒæ¡Zapæ—¥å¿—åº“çš„ä½¿ç”¨
- å­¦ä¹ æ—¥å¿—çº§åˆ«å’Œæ ¼å¼
- ç†è§£æ—¥å¿—è½®è½¬æœºåˆ¶
- æŒæ¡ç»“æ„åŒ–æ—¥å¿—

---

## ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦æ—¥å¿—ç³»ç»Ÿï¼Ÿ

### æ—¥å¿—çš„ä½œç”¨

1. **é—®é¢˜æ’æŸ¥**
   - ç¨‹åºå‡ºé”™æ—¶ï¼Œé€šè¿‡æ—¥å¿—å®šä½é—®é¢˜
   - äº†è§£ç¨‹åºæ‰§è¡Œæµç¨‹

2. **æ€§èƒ½ç›‘æ§**
   - è®°å½•è¯·æ±‚è€—æ—¶
   - å‘ç°æ€§èƒ½ç“¶é¢ˆ

3. **ä¸šåŠ¡åˆ†æ**
   - ç”¨æˆ·è¡Œä¸ºåˆ†æ
   - ä¸šåŠ¡æ•°æ®ç»Ÿè®¡

4. **å®‰å…¨å®¡è®¡**
   - è®°å½•æ•æ„Ÿæ“ä½œ
   - è¿½è¸ªå¼‚å¸¸è¡Œä¸º

---

## ğŸ“ æ ¸å¿ƒä»£ç ï¼šæ—¥å¿—ç³»ç»Ÿå®ç°

### å®Œæ•´ä»£ç ï¼ˆæ‰‹å†™ç»ƒä¹ ï¼‰

```go
package log

import (
    "HeronGame/common/middleware/mdx"
    "context"
    "fmt"
    "os"
    "path/filepath"
    "time"

    "github.com/go-kratos/kratos/v2/log"
    "go.opentelemetry.io/otel/trace"
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
    "gopkg.in/natefinch/lumberjack.v2"
)

// å…¨å±€åŸºç¡€æ—¥å¿—å™¨
var globalBaseLogger *zap.Logger

// InitGlobalLogger åˆå§‹åŒ–å…¨å±€æ—¥å¿—å·¥å…·
func InitGlobalLogger(baseLogger *zap.Logger) {
    globalBaseLogger = baseLogger
}

// ZapToKratosLogger å°†Zap loggerè½¬æ¢ä¸ºKratos logger
func ZapToKratosLogger() log.Logger {
    if globalBaseLogger == nil {
        return log.NewStdLogger(os.Stdout)
    }

    return &zapKratosAdapter{
        zapLogger: globalBaseLogger,
    }
}

// zapKratosAdapter é€‚é…å™¨ï¼Œå°†Kratos logæ¥å£è½¬æ¢ä¸ºZap logger
type zapKratosAdapter struct {
    zapLogger *zap.Logger
}

func (z *zapKratosAdapter) Log(level log.Level, keyvals ...interface{}) error {
    var zapLevel zapcore.Level
    switch level {
    case log.LevelDebug:
        zapLevel = zapcore.DebugLevel
    case log.LevelInfo:
        zapLevel = zapcore.InfoLevel
    case log.LevelWarn:
        zapLevel = zapcore.WarnLevel
    case log.LevelError:
        zapLevel = zapcore.ErrorLevel
    default:
        zapLevel = zapcore.InfoLevel
    }

    if !z.zapLogger.Core().Enabled(zapLevel) {
        return nil
    }

    // å°†keyvalsè½¬æ¢ä¸ºZap fields
    fields := make([]zap.Field, 0, len(keyvals)/2)
    for i := 0; i < len(keyvals); i += 2 {
        if i+1 < len(keyvals) {
            key, ok := keyvals[i].(string)
            if ok {
                fields = append(fields, zap.Any(key, keyvals[i+1]))
            }
        }
    }

    // ä½¿ç”¨Zap loggerè®°å½•æ—¥å¿—
    switch zapLevel {
    case zapcore.DebugLevel:
        z.zapLogger.Debug("", fields...)
    case zapcore.InfoLevel:
        z.zapLogger.Info("", fields...)
    case zapcore.WarnLevel:
        z.zapLogger.Warn("", fields...)
    case zapcore.ErrorLevel:
        z.zapLogger.Error("", fields...)
    }

    return nil
}

// Info è®°å½•Infoçº§åˆ«æ—¥å¿—
func Info(ctx context.Context, msg string, fields ...zap.Field) {
    logger := getLoggerFromContext(ctx, globalBaseLogger)
    allFields := mergeFields(fields, globalBaseFields)
    logger.Info(msg, allFields...)
}

// Error è®°å½•Errorçº§åˆ«æ—¥å¿—
func Error(ctx context.Context, msg string, fields ...zap.Field) {
    logger := getLoggerFromContext(ctx, globalBaseLogger)
    allFields := mergeFields(fields, globalBaseFields)
    logger.Error(msg, allFields...)
}

// Warn è®°å½•Warnçº§åˆ«æ—¥å¿—
func Warn(ctx context.Context, msg string, fields ...zap.Field) {
    logger := getLoggerFromContext(ctx, globalBaseLogger)
    allFields := mergeFields(fields, globalBaseFields)
    logger.Warn(msg, allFields...)
}

// Debug è®°å½•Debugçº§åˆ«æ—¥å¿—
func Debug(ctx context.Context, msg string, fields ...zap.Field) {
    logger := getLoggerFromContext(ctx, globalBaseLogger)
    allFields := mergeFields(fields, globalBaseFields)
    logger.Debug(msg, allFields...)
}

// InitZapLogger åˆå§‹åŒ–Zapæ—¥å¿—å™¨
func InitZapLogger(
    level, format string,
    outputs []string,
    fileConfigs []*FileConfig,
    serviceVersion, serviceID, environment string,
) (*zap.Logger, error) {
    // 1. éªŒè¯é…ç½®
    if err := validateLogConfig(level, format, outputs, fileConfigs); err != nil {
        return nil, fmt.Errorf("invalid log config: %w", err)
    }

    // 2. è§£ææ—¥å¿—çº§åˆ«
    zapLevel := parseLogLevel(level)

    // 3. åˆ›å»ºç¼–ç å™¨é…ç½®
    encoderConfig := createEncoderConfig()

    // 4. é…ç½®è¾“å‡ºè·¯å¾„
    var outputPaths []string
    var errorOutputPaths []string

    for _, output := range outputs {
        switch output {
        case "stdout":
            outputPaths = append(outputPaths, "stdout")
        case "stderr":
            errorOutputPaths = append(errorOutputPaths, "stderr")
        case "file":
            continue  // æ–‡ä»¶è¾“å‡ºç”±å¤šæ–‡ä»¶é…ç½®å¤„ç†
        }
    }

    if len(outputPaths) == 0 {
        outputPaths = []string{"stdout"}
    }
    if len(errorOutputPaths) == 0 {
        errorOutputPaths = []string{"stdout"}
    }

    // 5. é…ç½®Zap
    config := zap.NewProductionConfig()
    config.Level = zap.NewAtomicLevelAt(zapLevel)
    config.Encoding = format
    config.OutputPaths = outputPaths
    config.ErrorOutputPaths = errorOutputPaths
    config.EncoderConfig = encoderConfig

    // 6. åˆ›å»ºåŸºç¡€logger
    logger, err := config.Build(
        zap.AddCaller(),                    // æ·»åŠ è°ƒç”¨è€…ä¿¡æ¯
        zap.AddCallerSkip(1),              // è·³è¿‡ä¸€å±‚è°ƒç”¨æ ˆ
        zap.AddStacktrace(zapcore.ErrorLevel), // é”™è¯¯çº§åˆ«æ·»åŠ å †æ ˆ
        zap.AddStacktrace(zapcore.PanicLevel), // Panicçº§åˆ«æ·»åŠ å †æ ˆ
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create zap logger: %w", err)
    }

    // 7. å¦‚æœåŒ…å«æ–‡ä»¶è¾“å‡ºï¼Œåˆ›å»ºå¤šæ–‡ä»¶logger
    if contains(outputs, "file") && len(fileConfigs) > 0 {
        cores := []zapcore.Core{}

        // æ·»åŠ æ§åˆ¶å°è¾“å‡º
        if contains(outputs, "stdout") {
            var consoleEncoder zapcore.Encoder
            if format == "json" {
                consoleEncoder = zapcore.NewJSONEncoder(encoderConfig)
            } else {
                consoleEncoder = zapcore.NewConsoleEncoder(encoderConfig)
            }
            consoleCore := zapcore.NewCore(consoleEncoder, zapcore.AddSync(os.Stdout), zapLevel)
            cores = append(cores, consoleCore)
        }

        // æ·»åŠ æ–‡ä»¶è¾“å‡º
        for _, fileConfig := range fileConfigs {
            if fileConfig != nil && fileConfig.Path != "" {
                // ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
                if err := ensureLogDir(fileConfig.Path); err != nil {
                    return nil, fmt.Errorf("failed to create log directory for %s: %w", fileConfig.Path, err)
                }

                // è§£ææ–‡ä»¶çº§åˆ«
                fileLevel := parseLogLevel(fileConfig.Level)

                // åˆ›å»ºæ–‡ä»¶è¾“å‡º
                fileWriter, err := createFileWriter(fileConfig)
                if err != nil {
                    return nil, fmt.Errorf("failed to create file writer for %s: %w", fileConfig.Path, err)
                }

                // åˆ›å»ºæ–‡ä»¶core
                var fileEncoder zapcore.Encoder
                if format == "json" {
                    fileEncoder = zapcore.NewJSONEncoder(encoderConfig)
                } else {
                    fileEncoder = zapcore.NewConsoleEncoder(encoderConfig)
                }
                fileCore := zapcore.NewCore(fileEncoder, fileWriter, fileLevel)
                cores = append(cores, fileCore)
            }
        }

        // åˆ›å»ºå¤šæ ¸å¿ƒlogger
        if len(cores) > 0 {
            core := zapcore.NewTee(cores...)
            logger = zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1), zap.AddStacktrace(zapcore.ErrorLevel))
        }
    }

    // 8. å­˜å‚¨å…¨å±€åŸºç¡€å­—æ®µ
    globalBaseFields = []zap.Field{
        zap.String("service_id", serviceID),
        zap.String("service_version", serviceVersion),
        zap.String("environment", environment),
        zap.String("hostname", getHostname()),
        zap.Int("pid", os.Getpid()),
    }

    return logger, nil
}

// parseLogLevel è§£ææ—¥å¿—çº§åˆ«
func parseLogLevel(level string) zapcore.Level {
    switch level {
    case "debug":
        return zapcore.DebugLevel
    case "info":
        return zapcore.InfoLevel
    case "warn":
        return zapcore.WarnLevel
    case "error":
        return zapcore.ErrorLevel
    default:
        return zapcore.InfoLevel
    }
}

// createEncoderConfig åˆ›å»ºç¼–ç å™¨é…ç½®
func createEncoderConfig() zapcore.EncoderConfig {
    encoderConfig := zap.NewProductionEncoderConfig()

    encoderConfig.TimeKey = "timestamp"
    encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
    encoderConfig.EncodeCaller = zapcore.FullCallerEncoder
    encoderConfig.LevelKey = "level"
    encoderConfig.CallerKey = "caller"
    encoderConfig.MessageKey = "msg"

    return encoderConfig
}

// createFileWriter åˆ›å»ºæ–‡ä»¶å†™å…¥å™¨
func createFileWriter(fileConfig *FileConfig) (zapcore.WriteSyncer, error) {
    if fileConfig.Rotation != nil && fileConfig.Rotation.Enabled {
        // ä½¿ç”¨è½®è½¬
        lumberjackLogger := &lumberjack.Logger{
            Filename:   fileConfig.Path,
            MaxSize:    fileConfig.Rotation.MaxSize,
            MaxAge:     fileConfig.Rotation.MaxAge,
            MaxBackups: fileConfig.Rotation.MaxBackups,
            Compress:   true,
        }
        return zapcore.AddSync(lumberjackLogger), nil
    } else {
        // ç›´æ¥å†™å…¥æ–‡ä»¶
        file, err := os.OpenFile(fileConfig.Path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil {
            return nil, err
        }
        return zapcore.AddSync(file), nil
    }
}

// FileConfig æ–‡ä»¶é…ç½®
type FileConfig struct {
    Path     string
    Rotation *RotationConfig
    Level    string
}

// RotationConfig è½®è½¬é…ç½®
type RotationConfig struct {
    Enabled    bool
    MaxSize    int // MB
    MaxAge     int // days
    MaxBackups int
}

// getLoggerFromContext ä»contextä¸­è·å–logger
func getLoggerFromContext(ctx context.Context, baseLogger *zap.Logger) *zap.Logger {
    if ctx == nil {
        return baseLogger
    }

    if logger, ok := ctx.Value(mdx.CtxLogger).(*zap.Logger); ok && logger != nil {
        return logger
    }

    return baseLogger
}

// mergeFields åˆå¹¶å­—æ®µ
func mergeFields(customFields []zap.Field, globalFields []zap.Field) []zap.Field {
    if len(globalFields) == 0 {
        return customFields
    }
    if len(customFields) == 0 {
        return globalFields
    }

    result := make([]zap.Field, 0, len(customFields)+len(globalFields))
    result = append(result, customFields...)
    result = append(result, globalFields...)
    return result
}

// è¾…åŠ©å‡½æ•°
func ensureLogDir(filePath string) error {
    dir := filepath.Dir(filePath)
    if dir != "." && dir != "/" {
        return os.MkdirAll(dir, 0755)
    }
    return nil
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}

func getHostname() string {
    hostname, err := os.Hostname()
    if err != nil {
        return "unknown"
    }
    return hostname
}
```

---

## ğŸ“– ä»£ç è¯¦è§£

### 1. æ—¥å¿—çº§åˆ«

```go
// æ—¥å¿—çº§åˆ«ä»ä½åˆ°é«˜
Debug < Info < Warn < Error < Panic < Fatal
```

**ä½¿ç”¨åœºæ™¯ï¼š**
- **Debug**ï¼šå¼€å‘è°ƒè¯•ä¿¡æ¯
- **Info**ï¼šä¸€èˆ¬ä¿¡æ¯ï¼ˆè¯·æ±‚ã€å“åº”ç­‰ï¼‰
- **Warn**ï¼šè­¦å‘Šä¿¡æ¯ï¼ˆä¸å½±å“åŠŸèƒ½ï¼‰
- **Error**ï¼šé”™è¯¯ä¿¡æ¯ï¼ˆéœ€è¦å…³æ³¨ï¼‰
- **Panic/Fatal**ï¼šä¸¥é‡é”™è¯¯ï¼ˆç¨‹åºå¯èƒ½å´©æºƒï¼‰

### 2. æ—¥å¿—æ ¼å¼

**JSONæ ¼å¼ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰ï¼š**
```json
{
  "timestamp": "2024-01-01T12:00:00Z",
  "level": "INFO",
  "msg": "ç”¨æˆ·ç™»å½•æˆåŠŸ",
  "user_id": "123",
  "service_id": "gateway-001"
}
```

**Consoleæ ¼å¼ï¼ˆå¼€å‘ç¯å¢ƒï¼‰ï¼š**
```
2024-01-01T12:00:00Z  INFO  ç”¨æˆ·ç™»å½•æˆåŠŸ  user_id=123  service_id=gateway-001
```

### 3. æ—¥å¿—è½®è½¬

```go
lumberjackLogger := &lumberjack.Logger{
    Filename:   "logs/app.log",
    MaxSize:    100,      // å•ä¸ªæ–‡ä»¶æœ€å¤§100MB
    MaxAge:     7,        // ä¿ç•™7å¤©
    MaxBackups: 10,       // æœ€å¤šä¿ç•™10ä¸ªå¤‡ä»½æ–‡ä»¶
    Compress:   true,     // å‹ç¼©æ—§æ–‡ä»¶
}
```

**ä½œç”¨ï¼š**
- é˜²æ­¢æ—¥å¿—æ–‡ä»¶è¿‡å¤§
- è‡ªåŠ¨æ¸…ç†æ—§æ—¥å¿—
- èŠ‚çœç£ç›˜ç©ºé—´

### 4. ç»“æ„åŒ–æ—¥å¿—

```go
// ä½¿ç”¨ç»“æ„åŒ–å­—æ®µ
log.Info(ctx, "ç”¨æˆ·ç™»å½•",
    zap.String("user_id", "123"),
    zap.String("ip", "192.168.1.1"),
    zap.Duration("duration", time.Millisecond*100),
)
```

**ä¼˜åŠ¿ï¼š**
- æ˜“äºè§£æå’ŒæŸ¥è¯¢
- æ”¯æŒæ—¥å¿—åˆ†æå·¥å…·
- ä¾¿äºç›‘æ§å’Œå‘Šè­¦

### 5. Contextä¸­çš„æ—¥å¿—

```go
// ä»Contextè·å–loggerï¼Œå¯èƒ½åŒ…å«è¿½è¸ªä¿¡æ¯
logger := getLoggerFromContext(ctx, globalBaseLogger)
logger.Info("å¤„ç†è¯·æ±‚", zap.String("trace_id", traceID))
```

**å¥½å¤„ï¼š**
- è‡ªåŠ¨å…³è”è¯·æ±‚è¿½è¸ª
- åŒ…å«ç”¨æˆ·ä¿¡æ¯
- ä¾¿äºé—®é¢˜æ’æŸ¥

---

## ğŸ“ æ—¥å¿—æœ€ä½³å®è·µ

### 1. æ—¥å¿—çº§åˆ«é€‰æ‹©

```go
// âœ… å¥½çš„åšæ³•
log.Info(ctx, "ç”¨æˆ·ç™»å½•æˆåŠŸ", zap.String("user_id", userID))
log.Error(ctx, "æ•°æ®åº“è¿æ¥å¤±è´¥", zap.Error(err))

// âŒ ä¸å¥½çš„åšæ³•
log.Debug(ctx, "ç”¨æˆ·ç™»å½•æˆåŠŸ")  // åº”è¯¥ç”¨Info
log.Info(ctx, "æ•°æ®åº“è¿æ¥å¤±è´¥")  // åº”è¯¥ç”¨Error
```

### 2. ç»“æ„åŒ–å­—æ®µ

```go
// âœ… å¥½çš„åšæ³•ï¼šä½¿ç”¨ç»“æ„åŒ–å­—æ®µ
log.Info(ctx, "è®¢å•åˆ›å»º",
    zap.String("order_id", orderID),
    zap.Float64("amount", amount),
    zap.String("user_id", userID),
)

// âŒ ä¸å¥½çš„åšæ³•ï¼šå­—ç¬¦ä¸²æ‹¼æ¥
log.Info(ctx, fmt.Sprintf("è®¢å•åˆ›å»º order_id=%s amount=%.2f", orderID, amount))
```

### 3. é”™è¯¯æ—¥å¿—

```go
// âœ… å¥½çš„åšæ³•ï¼šåŒ…å«é”™è¯¯å’Œä¸Šä¸‹æ–‡
log.Error(ctx, "å¤„ç†è¯·æ±‚å¤±è´¥",
    zap.Error(err),
    zap.String("request_id", requestID),
    zap.String("user_id", userID),
)

// âŒ ä¸å¥½çš„åšæ³•ï¼šåªæœ‰é”™è¯¯ä¿¡æ¯
log.Error(ctx, err.Error())
```

### 4. æ€§èƒ½è€ƒè™‘

```go
// âœ… å¥½çš„åšæ³•ï¼šå…ˆæ£€æŸ¥çº§åˆ«
if logger.Core().Enabled(zapcore.DebugLevel) {
    logger.Debug("è¯¦ç»†ä¿¡æ¯", zap.Any("data", expensiveData))
}

// âŒ ä¸å¥½çš„åšæ³•ï¼šæ€»æ˜¯è®¡ç®—expensiveData
logger.Debug("è¯¦ç»†ä¿¡æ¯", zap.Any("data", expensiveData))
```

---

## ğŸ’¡ å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šç†è§£æ—¥å¿—çº§åˆ«

ç¼–å†™ä»£ç ï¼Œæµ‹è¯•ä¸åŒæ—¥å¿—çº§åˆ«çš„è¾“å‡ºï¼š

```go
func TestLogLevels() {
    logger, _ := zap.NewDevelopment()
    defer logger.Sync()

    logger.Debug("è¿™æ˜¯Debugæ—¥å¿—")
    logger.Info("è¿™æ˜¯Infoæ—¥å¿—")
    logger.Warn("è¿™æ˜¯Warnæ—¥å¿—")
    logger.Error("è¿™æ˜¯Erroræ—¥å¿—")
}
```

### ç»ƒä¹ 2ï¼šæ—¥å¿—è½®è½¬

é…ç½®æ—¥å¿—è½®è½¬ï¼Œè§‚å¯Ÿæ–‡ä»¶å˜åŒ–ï¼š
- å†™å…¥å¤§é‡æ—¥å¿—
- è§‚å¯Ÿæ–‡ä»¶æ˜¯å¦è‡ªåŠ¨è½®è½¬
- æ£€æŸ¥æ—§æ–‡ä»¶æ˜¯å¦è¢«å‹ç¼©

### ç»ƒä¹ 3ï¼šç»“æ„åŒ–æ—¥å¿—

ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œè®°å½•ç”¨æˆ·æ“ä½œæ—¥å¿—ï¼š

```go
func LogUserAction(ctx context.Context, userID string, action string, success bool) {
    // TODO: å®ç°æ—¥å¿—è®°å½•
}
```

---

## ğŸ“Œ ä¸‹ä¸€é˜¶æ®µé¢„å‘Š

**é˜¶æ®µ6ï¼šæ•°æ®è®¿é—®å±‚**
- Rediså®¢æˆ·ç«¯å°è£…
- è¿æ¥æ± ç®¡ç†
- æ•°æ®è®¿é—®æ¨¡å¼

---

## â“ æ€è€ƒé¢˜

1. ä¸ºä»€ä¹ˆç”Ÿäº§ç¯å¢ƒæ¨èä½¿ç”¨JSONæ ¼å¼çš„æ—¥å¿—ï¼Ÿ
2. æ—¥å¿—è½®è½¬çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿå¦‚æœä¸è½®è½¬ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
3. ç»“æ„åŒ–æ—¥å¿—å’Œæ™®é€šå­—ç¬¦ä¸²æ—¥å¿—æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿå„æœ‰ä»€ä¹ˆä¼˜ç¼ºç‚¹ï¼Ÿ
4. å¦‚ä½•é€šè¿‡æ—¥å¿—è¿½è¸ªä¸€ä¸ªè¯·æ±‚çš„å®Œæ•´æµç¨‹ï¼Ÿ

---

**å®Œæˆæœ¬é˜¶æ®µåï¼Œè¯·ç»§ç»­å­¦ä¹ é˜¶æ®µ6ï¼** ğŸš€


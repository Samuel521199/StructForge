# 阶段2：程序入口和配置系统

## 📚 学习目标
- 理解Go程序的启动流程
- 掌握配置文件的加载机制
- 学习环境变量的使用
- 理解日志系统的初始化

---

## 🚀 核心代码：main.go（程序入口）

### 完整代码（手写练习）

```go
package main

import (
    "HeronGame/apps/gateway/internal/conf"
    "HeronGame/apps/gateway/internal/data/client"
    "HeronGame/apps/gateway/internal/server"
    "HeronGame/common/log"
    commConf "HeronGame/common/server/conf"
    nacosConfClient "HeronGame/common/server/nacos"
    "HeronGame/game/errors"
    "context"
    "flag"
    "fmt"
    "os"

    "github.com/go-kratos/kratos/contrib/registry/nacos/v2"
    "github.com/go-kratos/kratos/v2"
    "github.com/go-kratos/kratos/v2/config"
    "github.com/go-kratos/kratos/v2/config/file"
    "github.com/go-kratos/kratos/v2/transport/grpc"
    "go.uber.org/automaxprocs/maxprocs"
    "go.uber.org/zap"
)

// 命令行参数定义
var (
    flagconf string  // 配置文件路径
    flagenv  string  // 环境标识（local/test/prod）
)

// init函数：程序启动时自动执行
func init() {
    // 默认环境为 local
    flag.StringVar(&flagenv, "env", "local", "environment: local, test, prod")
    flag.StringVar(&flagconf, "conf", "", "config path, eg: -conf gateway.yaml")
}

// getConfigPath 根据环境获取配置文件路径
func getConfigPath() string {
    // 如果指定了具体的配置文件路径，直接使用
    if flagconf != "" {
        return flagconf
    }

    // 优先使用环境变量，然后使用命令行参数
    env := os.Getenv("APP_ENV")
    if env == "" {
        env = flagenv
    }

    // 根据环境获取配置文件路径
    var configPath string
    switch env {
    case "local":
        configPath = "../../../../configs/local/gateway.yaml"
    case "test":
        configPath = "../../../../configs/test/gateway.yaml"
    case "prod":
        configPath = "../../../../configs/prod/gateway.yaml"
    default:
        fmt.Printf("Unknown environment: %s, using local environment\n", env)
        configPath = "../../../../configs/local/gateway.yaml"
    }

    // 检查配置文件是否存在
    if _, err := os.Stat(configPath); os.IsNotExist(err) {
        fmt.Printf("Config file not found: %s\n", configPath)
        fmt.Printf("Available environments: local, test, prod\n")
        os.Exit(1)
    }

    return configPath
}

// main函数：程序主入口
func main() {
    // 1. 解析命令行参数
    flag.Parse()

    // 2. 设置最大 CPU 核心数（自动适配容器环境）
    _, err := maxprocs.Set()
    if err != nil {
        panic(err)
    }

    // 3. 获取配置文件路径
    configPath := getConfigPath()
    env := os.Getenv("APP_ENV")
    if env == "" {
        env = flagenv
    }
    fmt.Printf("Loading config from: %s (environment: %s)\n", configPath, env)

    // 4. 加载启动配置文件（StartupConfig）
    c := config.New(config.WithSource(
        file.NewSource(configPath),
    ))
    defer c.Close()

    if err := c.Load(); err != nil {
        panic(err)
    }

    // 5. 解析启动配置
    var startupConfig commConf.StartupConfig
    if err := c.Scan(&startupConfig); err != nil {
        panic(err)
    }

    // 6. 创建 Nacos 配置客户端（用于从配置中心获取完整配置）
    nacosConfigClient, err := nacosConfClient.NewNacosConfigClient(&startupConfig)
    if err != nil {
        panic(fmt.Errorf("failed to create nacos config client: %w", err))
    }

    // 7. 从 Nacos 获取完整配置（Bootstrap）
    dm, err := client.NewConfigManager(nacosConfigClient, &startupConfig)
    if err != nil {
        panic(fmt.Errorf("failed to get bootstrap config from nacos: %w", err))
    }
    bc := dm.GetBootstrap()

    // 8. 初始化日志系统
    zapLogger, err := initLogger(bc)
    if err != nil {
        panic(err)
    }
    defer func(zapLogger *zap.Logger) {
        err := zapLogger.Sync()
        if err != nil {
            zapLogger.Error("zap logger error", zap.Error(err))
        }
    }(zapLogger)

    // 9. 初始化全局日志工具
    log.InitGlobalLogger(zapLogger)

    // 10. 使用Wire进行依赖注入，创建应用实例
    app, cleanup, err := wireApp(bc, bc.Redis)
    if err != nil {
        panic(errors.Wrap(err, "gateway 服务初始化失败"))
    }
    defer cleanup()

    // 11. 记录启动日志
    log.Info(context.Background(), "[gateway] gateway 服务开始运行",
        zap.String("server_id", bc.Server.Id),
        zap.String("env_pod_name", os.Getenv("POD_NAME")),
        zap.String("env_hostname", os.Getenv("HOSTNAME")),
        zap.String("env_namespace", os.Getenv("POD_NAMESPACE")))

    // 12. 启动服务并等待停止信号
    if err := app.Run(); err != nil {
        log.Info(context.Background(), "[gateway] gateway 触发服务关闭",
            zap.String("server_id", bc.Server.Id),
            zap.String("pod_name", os.Getenv("POD_NAME")),
            zap.String("hostname", os.Getenv("HOSTNAME")),
            zap.Error(err))
        panic(errors.Wrap(err, "gateway 服务运行失败"))
    }

    log.Info(context.Background(), "[gateway] gateway 服务结束运行",
        zap.String("server_id", bc.Server.Id),
        zap.String("pod_name", os.Getenv("POD_NAME")),
        zap.String("hostname", os.Getenv("HOSTNAME")))
}

// initLogger 初始化日志系统
func initLogger(bc *conf.Bootstrap) (*zap.Logger, error) {
    // 根据配置初始化文件配置
    var fileConfigs []*log.FileConfig
    for _, fileLog := range bc.Logging.Files {
        fileConfigs = append(fileConfigs, &log.FileConfig{
            Path:  fileLog.Path,
            Level: fileLog.Level,
            Rotation: &log.RotationConfig{
                Enabled:    fileLog.Rotation.Enabled,
                MaxSize:    int(fileLog.Rotation.MaxSize),
                MaxAge:     int(fileLog.Rotation.MaxAge),
                MaxBackups: int(fileLog.Rotation.MaxBackups),
            },
        })
    }

    // 初始化Zap日志系统
    return log.InitZapLogger(
        bc.Logging.Level,
        bc.Logging.Format,
        bc.Logging.Outputs,
        fileConfigs,
        bc.Server.Version,
        bc.Server.Id,
        bc.Logging.Environment,
    )
}

// newApp 创建Kratos应用实例
func newApp(bc *conf.Bootstrap, gs *grpc.Server, ws *server.WebSocketServer, registry *nacos.Registry) *kratos.App {
    return kratos.New(
        kratos.ID(bc.Server.Id),              // 服务ID
        kratos.Metadata(map[string]string{
            "service_id": bc.Server.Id,
        }),
        kratos.Name(bc.Server.Name),          // 服务名称
        kratos.Version(bc.Server.Version),     // 服务版本
        kratos.Logger(log.ZapToKratosLogger()), // 日志
        kratos.Registrar(registry),           // 服务注册
        kratos.Server(                        // 注册服务器
            ws,  // WebSocket服务器
            gs,  // gRPC服务器
        ),
    )
}
```

---

## 📖 代码详解

### 1. **包声明和导入**

```go
package main  // main包表示这是一个可执行程序

import (
    // 项目内部包
    "HeronGame/apps/gateway/internal/conf"
    
    // 第三方库
    "github.com/go-kratos/kratos/v2"
    
    // 标准库
    "context"
    "flag"
    "os"
)
```

**知识点：**
- `package main`：Go语言中，只有main包才能编译成可执行程序
- 导入路径：Go使用完整路径导入包，如 `github.com/go-kratos/kratos/v2`
- 别名导入：`commConf "HeronGame/common/server/conf"` 使用别名避免冲突

### 2. **命令行参数处理**

```go
var (
    flagconf string
    flagenv  string
)

func init() {
    flag.StringVar(&flagenv, "env", "local", "environment: local, test, prod")
    flag.StringVar(&flagconf, "conf", "", "config path")
}
```

**知识点：**
- `flag` 包：Go标准库，用于处理命令行参数
- `StringVar`：将命令行参数绑定到变量
- `init()` 函数：程序启动时自动执行，在 `main()` 之前

**使用示例：**
```bash
# 运行程序时指定环境
go run main.go -env=prod

# 运行程序时指定配置文件
go run main.go -conf=/path/to/config.yaml
```

### 3. **配置文件加载**

```go
// 创建配置加载器
c := config.New(config.WithSource(
    file.NewSource(configPath),  // 从文件加载
))
defer c.Close()  // 确保资源释放

// 加载配置
if err := c.Load(); err != nil {
    panic(err)
}

// 解析配置到结构体
var startupConfig commConf.StartupConfig
if err := c.Scan(&startupConfig); err != nil {
    panic(err)
}
```

**知识点：**
- `defer`：延迟执行，函数返回前执行，用于资源清理
- `panic`：Go语言的异常机制，程序会立即停止
- `config.Scan()`：将配置解析到结构体

### 4. **环境变量使用**

```go
// 获取环境变量
env := os.Getenv("APP_ENV")
if env == "" {
    env = flagenv  // 如果环境变量不存在，使用命令行参数
}
```

**知识点：**
- `os.Getenv()`：获取环境变量
- 优先级：环境变量 > 命令行参数 > 默认值

### 5. **日志系统初始化**

```go
// 初始化日志
zapLogger, err := initLogger(bc)
if err != nil {
    panic(err)
}

// defer确保程序退出前刷新日志缓冲区
defer func(zapLogger *zap.Logger) {
    err := zapLogger.Sync()
    if err != nil {
        zapLogger.Error("zap logger error", zap.Error(err))
    }
}(zapLogger)

// 设置为全局日志
log.InitGlobalLogger(zapLogger)
```

**知识点：**
- `defer` 的匿名函数：可以传递参数
- `Sync()`：刷新日志缓冲区，确保所有日志都写入文件
- 全局日志：方便在整个项目中使用

### 6. **应用启动**

```go
// 使用Wire进行依赖注入（下一阶段详细讲解）
app, cleanup, err := wireApp(bc, bc.Redis)
if err != nil {
    panic(err)
}
defer cleanup()  // 确保资源清理

// 启动服务
if err := app.Run(); err != nil {
    panic(err)
}
```

**知识点：**
- `wireApp`：Wire生成的依赖注入函数（下一阶段讲解）
- `app.Run()`：启动Kratos应用，会阻塞直到收到停止信号
- 优雅关闭：收到SIGTERM或SIGINT信号时，会执行cleanup函数

---

## 🔧 配置文件结构

### YAML配置文件示例

```yaml
# configs/local/gateway.yaml
server:
  name: gateway-service
  id: gateway-001
  version: v1.0.0
  env: local
  http:
    addr: 0.0.0.0:8000
    timeout: 30s
  grpc:
    addr: 0.0.0.0:9000
    timeout: 10s
  websocket:
    addr: 0.0.0.0:8080
    timeout: 30s

redis:
  addr: localhost:6379
  db: 0
  password: ""

logging:
  level: info
  format: json
  outputs:
    - stdout
    - file
  files:
    - path: logs/gateway.log
      level: info
      rotation:
        enabled: true
        max_size: 100
        max_age: 7
        max_backups: 10
```

---

## 🎓 关键概念

### 1. **配置管理策略**

```
启动配置文件（本地YAML）
    ↓
Nacos配置中心（远程配置）
    ↓
完整配置（Bootstrap）
```

**为什么这样设计？**
- 本地配置：包含Nacos连接信息（启动必需）
- Nacos配置：动态配置，可以热更新
- 分离关注点：启动配置和业务配置分离

### 2. **环境管理**

支持三种环境：
- **local**：本地开发环境
- **test**：测试环境
- **prod**：生产环境

**切换方式：**
```bash
# 方式1：命令行参数
go run main.go -env=prod

# 方式2：环境变量
export APP_ENV=prod
go run main.go
```

### 3. **错误处理模式**

```go
// Go语言的错误处理模式
result, err := someFunction()
if err != nil {
    // 处理错误
    return err  // 或 panic(err)
}
// 继续使用result
```

**与异常的区别：**
- Go没有异常机制，使用 `error` 返回值
- 必须显式检查错误
- 错误是值，可以传递和比较

---

## 💡 实践练习

### 练习1：理解配置加载流程

画出配置加载的流程图，包括：
1. 命令行参数解析
2. 环境变量读取
3. 本地配置文件加载
4. Nacos配置获取

### 练习2：手写代码

1. 手写 `main.go` 的完整代码
2. 理解每一行的作用
3. 尝试修改环境切换逻辑

### 练习3：运行测试

```bash
# 1. 进入gateway目录
cd apps/gateway/cmd/gateway

# 2. 运行程序（需要先配置好配置文件）
go run main.go wire_gen.go -env=local

# 3. 观察启动日志
```

---

## 📌 下一阶段预告

**阶段3：依赖注入（Wire）**
- 学习Wire的工作原理
- 理解依赖注入的好处
- 掌握Provider和ProviderSet的使用

---

## ❓ 思考题

1. 为什么要在 `init()` 函数中定义命令行参数？
2. `defer` 的执行顺序是什么？如果有多个 `defer`，执行顺序如何？
3. 为什么要使用Nacos配置中心？直接读取本地配置文件不行吗？
4. `panic` 和 `error` 的区别是什么？什么时候用 `panic`，什么时候用 `error`？

---

**完成本阶段后，请继续学习阶段3！** 🚀


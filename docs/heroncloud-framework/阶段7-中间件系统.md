# é˜¶æ®µ7ï¼šä¸­é—´ä»¶ç³»ç»Ÿ

## ğŸ“š å­¦ä¹ ç›®æ ‡
- ç†è§£ä¸­é—´ä»¶çš„æ¦‚å¿µå’Œä½œç”¨
- æŒæ¡ä¸­é—´ä»¶çš„å®ç°æ–¹å¼
- å­¦ä¹ JWTè®¤è¯ä¸­é—´ä»¶
- ç†è§£é™æµã€é”™è¯¯å¤„ç†ã€é“¾è·¯è¿½è¸ªä¸­é—´ä»¶

---

## ğŸ¯ ä»€ä¹ˆæ˜¯ä¸­é—´ä»¶ï¼Ÿ

### ä¸­é—´ä»¶çš„æ¦‚å¿µ

**ä¸­é—´ä»¶ï¼ˆMiddlewareï¼‰** æ˜¯åœ¨è¯·æ±‚å¤„ç†æµç¨‹ä¸­æ’å…¥çš„ç»„ä»¶ï¼Œç”¨äºï¼š
- åœ¨è¯·æ±‚åˆ°è¾¾ä¸šåŠ¡é€»è¾‘å‰è¿›è¡Œå¤„ç†
- åœ¨å“åº”è¿”å›å‰è¿›è¡Œå¤„ç†
- ç»Ÿä¸€å¤„ç†æ¨ªåˆ‡å…³æ³¨ç‚¹ï¼ˆè®¤è¯ã€æ—¥å¿—ã€é™æµç­‰ï¼‰

### ä¸­é—´ä»¶æ‰§è¡Œæµç¨‹

```
è¯·æ±‚ â†’ [ä¸­é—´ä»¶1] â†’ [ä¸­é—´ä»¶2] â†’ [ä¸­é—´ä»¶3] â†’ ä¸šåŠ¡å¤„ç†
     â† [ä¸­é—´ä»¶1] â† [ä¸­é—´ä»¶2] â† [ä¸­é—´ä»¶3] â† å“åº”
```

**ç‰¹ç‚¹ï¼š**
- æŒ‰é¡ºåºæ‰§è¡Œ
- å¯ä»¥ä¿®æ”¹è¯·æ±‚å’Œå“åº”
- å¯ä»¥æå‰ç»ˆæ­¢è¯·æ±‚

---

## ğŸ” JWTè®¤è¯ä¸­é—´ä»¶

### å®Œæ•´ä»£ç ï¼ˆæ‰‹å†™ç»ƒä¹ ï¼‰

```go
package jwt

import (
    commonpb "HeronGame/api/common/v1/pb"
    "HeronGame/common/jwt"
    gameErrors "HeronGame/game/errors"
    "context"
    "net/http"
    "regexp"
    "strings"

    "github.com/go-kratos/kratos/v2/middleware"
    "github.com/go-kratos/kratos/v2/transport"
)

// TokenValidator token éªŒè¯æ¥å£
type TokenValidator interface {
    ValidateToken(ctx context.Context, userID int64, token string) (bool, error)
}

// compilePathPatterns å°†è·¯å¾„åˆ—è¡¨ç¼–è¯‘ä¸ºæ­£åˆ™è¡¨è¾¾å¼åˆ—è¡¨
func compilePathPatterns(whitelist []string) []*regexp.Regexp {
    patterns := make([]*regexp.Regexp, 0, len(whitelist))
    for _, path := range whitelist {
        // å°†è·¯å¾„è½¬æ¢ä¸ºæ­£åˆ™è¡¨è¾¾å¼
        pattern := "^" + path
        // å¤„ç†å‚æ•°ï¼Œå°† :param è½¬æ¢ä¸º [^/]+
        pattern = regexp.MustCompile(`:[^/]+`).ReplaceAllString(pattern, "[^/]+")
        // å¤„ç†é€šé…ç¬¦
        pattern = strings.ReplaceAll(pattern, "*", ".*")
        // ç¡®ä¿è·¯å¾„ç»“æŸ
        pattern = pattern + "$"

        // é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼
        re := regexp.MustCompile(pattern)
        patterns = append(patterns, re)
    }
    return patterns
}

// JWTAuth JWT è®¤è¯ä¸­é—´ä»¶
func JWTAuth(secret string, signingMethod string, whitelist []string, validator TokenValidator) middleware.Middleware {
    // 1. ç¼–è¯‘ç™½åå•è·¯å¾„ä¸ºæ­£åˆ™è¡¨è¾¾å¼
    patterns := compilePathPatterns(whitelist)
    
    // 2. è¿”å›ä¸­é—´ä»¶å‡½æ•°
    return func(handler middleware.Handler) middleware.Handler {
        return func(ctx context.Context, req interface{}) (reply interface{}, err error) {
            // 3. è·å–ä¼ è¾“å±‚ä¿¡æ¯
            tr, ok := transport.FromServerContext(ctx)
            if !ok {
                return nil, gameErrors.New(int32(commonpb.ErrorCode_TOKEN_INVALID), "æ— æ•ˆtoken")
            }

            // 4. æ£€æŸ¥æ˜¯å¦åœ¨ç™½åå•ä¸­
            path := getRequestPath(tr)
            if isWhitelist(path, patterns) {
                // ç™½åå•è·¯å¾„ï¼Œç›´æ¥é€šè¿‡
                reply, err = handler(ctx, req)
                return reply, err
            }

            // 5. è·å– token
            auths := tr.RequestHeader().Get("Authorization")
            if auths == "" {
                return nil, gameErrors.New(int32(commonpb.ErrorCode_TOKEN_INVALID), "tokenç¼ºå¤±")
            }

            // 6. ä» Bearer token ä¸­æå– token
            parts := strings.SplitN(auths, " ", 2)
            if !(len(parts) == 2 && parts[0] == "Bearer") {
                return nil, gameErrors.New(int32(commonpb.ErrorCode_TOKEN_INVALID), "tokenæ ¼å¼é”™è¯¯")
            }

            token := parts[1]

            // 7. è§£æ token
            claims, err := jwt.ParseToken(token, secret, signingMethod)
            if err != nil {
                return nil, gameErrors.New(int32(commonpb.ErrorCode_TOKEN_INVALID), "tokenæ— æ•ˆ")
            }

            // 8. éªŒè¯ token æ˜¯å¦åœ¨ Redis ä¸­æœ‰æ•ˆï¼ˆå¯é€‰ï¼‰
            if validator != nil {
                isValidate, err := validator.ValidateToken(ctx, claims.UserID, token)
                if err != nil {
                    return nil, err
                }
                if !isValidate {
                    return nil, gameErrors.New(int32(commonpb.ErrorCode_AUTH_FAILED), "tokenè®¤è¯å¤±è´¥")
                }
            }

            // 9. å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥ä¸Šä¸‹æ–‡
            ctx = context.WithValue(ctx, "user_id", claims.UserID)
            ctx = context.WithValue(ctx, "user_name", claims.Username)
            ctx = context.WithValue(ctx, "user_nickname", claims.Nickname)
            ctx = context.WithValue(ctx, "user_avatar", claims.Avatar)
            
            // 10. ç»§ç»­å¤„ç†è¯·æ±‚
            reply, err = handler(ctx, req)
            return reply, err
        }
    }
}

// isWhitelist æ£€æŸ¥è·¯å¾„æ˜¯å¦åœ¨ç™½åå•ä¸­
func isWhitelist(path string, patterns []*regexp.Regexp) bool {
    for _, pattern := range patterns {
        if pattern.MatchString(path) {
            return true
        }
    }
    return false
}

// getRequestPath è·å–è¯·æ±‚è·¯å¾„
func getRequestPath(tr transport.Transporter) string {
    if tr.Kind() == transport.KindHTTP {
        if ht, ok := tr.(interface {
            Request() *http.Request
        }); ok {
            return ht.Request().URL.Path
        }
    }
    return ""
}
```

---

## ğŸ“– JWTä¸­é—´ä»¶è¯¦è§£

### 1. ä¸­é—´ä»¶å‡½æ•°ç­¾å

```go
func JWTAuth(...) middleware.Middleware {
    return func(handler middleware.Handler) middleware.Handler {
        return func(ctx context.Context, req interface{}) (reply interface{}, err error) {
            // ä¸­é—´ä»¶é€»è¾‘
        }
    }
}
```

**ä¸‰å±‚åµŒå¥—å‡½æ•°ï¼š**
- å¤–å±‚ï¼šé…ç½®å‡½æ•°ï¼Œæ¥æ”¶å‚æ•°ï¼Œè¿”å›ä¸­é—´ä»¶
- ä¸­å±‚ï¼šä¸­é—´ä»¶å‡½æ•°ï¼Œæ¥æ”¶Handlerï¼Œè¿”å›æ–°Handler
- å†…å±‚ï¼šå®é™…å¤„ç†å‡½æ•°ï¼Œå¤„ç†è¯·æ±‚

### 2. ç™½åå•æœºåˆ¶

```go
// ç™½åå•è·¯å¾„ç¤ºä¾‹
whitelist := []string{
    "/api/v1/login",      // ç™»å½•æ¥å£
    "/api/v1/register",  // æ³¨å†Œæ¥å£
    "/api/v1/health",     // å¥åº·æ£€æŸ¥
    "/api/v1/public/*",   // å…¬å…±æ¥å£ï¼ˆé€šé…ç¬¦ï¼‰
}
```

**ä½œç”¨ï¼š**
- æŸäº›æ¥å£ä¸éœ€è¦è®¤è¯ï¼ˆå¦‚ç™»å½•ã€æ³¨å†Œï¼‰
- æé«˜æ€§èƒ½ï¼ˆè·³è¿‡è®¤è¯æ£€æŸ¥ï¼‰
- çµæ´»é…ç½®

### 3. Tokenæå–

```go
// Authorization: Bearer <token>
auths := tr.RequestHeader().Get("Authorization")
parts := strings.SplitN(auths, " ", 2)
token := parts[1]  // æå–token
```

**æ ‡å‡†æ ¼å¼ï¼š**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 4. ç”¨æˆ·ä¿¡æ¯æ³¨å…¥

```go
ctx = context.WithValue(ctx, "user_id", claims.UserID)
ctx = context.WithValue(ctx, "user_name", claims.Username)
```

**ä½œç”¨ï¼š**
- ä¸šåŠ¡ä»£ç å¯ä»¥ä»Contextè·å–ç”¨æˆ·ä¿¡æ¯
- ä¸éœ€è¦é‡å¤è§£æToken
- æé«˜æ€§èƒ½

---

## ğŸš¦ é™æµä¸­é—´ä»¶

### å®Œæ•´ä»£ç ï¼ˆæ‰‹å†™ç»ƒä¹ ï¼‰

```go
package ratelimit

import (
    "context"
    "github.com/go-kratos/kratos/v2/middleware"
    "go.uber.org/zap"
    commonpb "HeronGame/api/common/v1/pb"
    "HeronGame/common/log"
    gameErrors "HeronGame/game/errors"
)

// RateLimit é™æµä¸­é—´ä»¶
func RateLimit(limiter *GatewayRateLimiter) middleware.Middleware {
    return func(handler middleware.Handler) middleware.Handler {
        return func(ctx context.Context, req interface{}) (interface{}, error) {
            // 1. æå–è¯·æ±‚ä¿¡æ¯
            request := limiter.extractRequestInfo(ctx, req)

            // 2. æ‰§è¡Œé™æµæ£€æŸ¥
            allowed, err := limiter.AllowMulti(ctx, request)
            if err != nil {
                // è®°å½•é”™è¯¯æ—¥å¿—
                log.Error(ctx, "rate_limit_error",
                    zap.Error(err),
                    zap.Any("request", request))
                return nil, err
            }

            // 3. å¦‚æœè¢«é™æµï¼Œè¿”å›é”™è¯¯
            if !allowed {
                // è®°å½•é™æµäº‹ä»¶
                log.Info(ctx, "rate_limit_exceeded",
                    zap.Any("request", request))
                return nil, gameErrors.New(int32(commonpb.ErrorCode_REQUEST_TO_BUSY), "è¯·æ±‚è¿‡äºé¢‘ç¹")
            }

            // 4. é€šè¿‡é™æµæ£€æŸ¥ï¼Œç»§ç»­å¤„ç†è¯·æ±‚
            return handler(ctx, req)
        }
    }
}
```

---

## ğŸ“– é™æµä¸­é—´ä»¶è¯¦è§£

### é™æµçš„ä½œç”¨

1. **é˜²æ­¢ç³»ç»Ÿè¿‡è½½**
   - é™åˆ¶è¯·æ±‚é¢‘ç‡
   - ä¿æŠ¤åç«¯æœåŠ¡

2. **é˜²æ­¢æ¶æ„æ”»å‡»**
   - é˜²æ­¢DDoSæ”»å‡»
   - é˜²æ­¢æš´åŠ›ç ´è§£

3. **å…¬å¹³ä½¿ç”¨èµ„æº**
   - ç¡®ä¿æ‰€æœ‰ç”¨æˆ·å…¬å¹³ä½¿ç”¨
   - é˜²æ­¢å•ä¸ªç”¨æˆ·å ç”¨è¿‡å¤šèµ„æº

### é™æµç®—æ³•

**æ»‘åŠ¨çª—å£ç®—æ³•ï¼š**
```
æ—¶é—´çª—å£ï¼š1åˆ†é’Ÿ
æœ€å¤§è¯·æ±‚æ•°ï¼š100

[0:00-1:00] çª—å£1ï¼š80æ¬¡è¯·æ±‚ âœ…
[0:01-1:01] çª—å£2ï¼š90æ¬¡è¯·æ±‚ âœ…
[0:02-1:02] çª—å£3ï¼š101æ¬¡è¯·æ±‚ âŒ é™æµ
```

---

## âš ï¸ é”™è¯¯å¤„ç†ä¸­é—´ä»¶

### å®Œæ•´ä»£ç ï¼ˆæ‰‹å†™ç»ƒä¹ ï¼‰

```go
package error

import (
    commonpb "HeronGame/api/common/v1/pb"
    "HeronGame/common/log"
    "HeronGame/common/utils"
    gameErrors "HeronGame/game/errors"
    "encoding/json"
    "fmt"
    "net/http"
    "strings"

    "github.com/go-kratos/kratos/v2/errors"
    "go.uber.org/zap"
)

// Response ç»Ÿä¸€å“åº”ç»“æ„
type Response struct {
    Code    int32  `json:"code"`
    Message string `json:"msg"`
}

// ErrorsEncoder é”™è¯¯ç¼–ç å™¨
func ErrorsEncoder(w http.ResponseWriter, r *http.Request, err error) {
    code := int32(commonpb.ErrorCode_INTERNAL_SERVER_ERROR)
    message := "Server error"

    ctx := r.Context()

    // è·å–ç”¨æˆ·ä¿¡æ¯
    userInfo := utils.GetUserInfo(ctx)

    // æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªå®šä¹‰é”™è¯¯
    var appErr *gameErrors.Error
    if errors.As(err, &appErr) {
        // æå–æ–¹æ³•å
        methodName := appErr.Function
        if appErr.Function != "" {
            if lastDot := strings.LastIndex(appErr.Function, "."); lastDot != -1 {
                methodName = appErr.Function[lastDot+1:]
            }
        }

        // æ‹¼æ¥ä½ç½®ä¿¡æ¯
        location := fmt.Sprintf("%s:%s:%d", appErr.File, methodName, appErr.Line)

        log.Info(ctx, "http system error occurred",
            zap.String("location", location),
            zap.Int32("error_code", appErr.Code),
            zap.Any("err", err),
            zap.Any("user_info", userInfo))

        code = appErr.Code
        message = appErr.Message
    } else {
        // æ£€æŸ¥æ˜¯å¦ä¸ºKratosé”™è¯¯
        if kratosErr, ok := err.(*errors.Error); ok {
            code = kratosErr.Code
            message = kratosErr.Message
        }

        // éè‡ªå®šä¹‰é”™è¯¯ï¼Œè®°å½•ä¸ºé”™è¯¯æ—¥å¿—
        log.Error(ctx, "http system error occurred",
            zap.Any("err", err),
            zap.Any("user_info", userInfo))
    }

    // å“åº”å®¢æˆ·ç«¯
    body, err := json.Marshal(&Response{
        Code:    code,
        Message: message,
    })

    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    _, _ = w.Write(body)
}
```

---

## ğŸ“– é”™è¯¯å¤„ç†è¯¦è§£

### ç»Ÿä¸€é”™è¯¯å“åº”

```json
{
  "code": 1001,
  "msg": "ç”¨æˆ·ä¸å­˜åœ¨"
}
```

**å¥½å¤„ï¼š**
- å®¢æˆ·ç«¯ç»Ÿä¸€å¤„ç†
- é”™è¯¯ç æ ‡å‡†åŒ–
- ä¾¿äºå›½é™…åŒ–

### é”™è¯¯åˆ†ç±»

1. **ä¸šåŠ¡é”™è¯¯**ï¼ˆè‡ªå®šä¹‰é”™è¯¯ï¼‰
   - æœ‰æ˜ç¡®çš„é”™è¯¯ç å’Œæ¶ˆæ¯
   - è®°å½•ä¸ºInfoçº§åˆ«æ—¥å¿—

2. **ç³»ç»Ÿé”™è¯¯**ï¼ˆæœªçŸ¥é”™è¯¯ï¼‰
   - æ²¡æœ‰æ˜ç¡®çš„é”™è¯¯ç 
   - è®°å½•ä¸ºErrorçº§åˆ«æ—¥å¿—
   - è¿”å›é€šç”¨é”™è¯¯ä¿¡æ¯

---

## ğŸ” é“¾è·¯è¿½è¸ªä¸­é—´ä»¶

### å®Œæ•´ä»£ç ï¼ˆæ‰‹å†™ç»ƒä¹ ï¼‰

```go
package tracing

import (
    "HeronGame/common/log"
    "HeronGame/common/middleware/mdx"
    "HeronGame/common/utils"
    "context"
    "fmt"
    "net/http"
    "time"

    "github.com/go-kratos/kratos/v2/middleware"
    "github.com/go-kratos/kratos/v2/transport"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
)

// HTTPTracingMiddleware HTTPè¿½è¸ªä¸­é—´ä»¶
func HTTPTracingMiddleware(serverName string, serviceName string) middleware.Middleware {
    return func(handler middleware.Handler) middleware.Handler {
        return func(ctx context.Context, req interface{}) (reply interface{}, err error) {
            startTime := time.Now()

            // 1. ä»transportä¸Šä¸‹æ–‡è·å–HTTPè¯·æ±‚ä¿¡æ¯
            var httpReq *http.Request
            var method, path string

            if tr, ok := transport.FromServerContext(ctx); ok {
                if ht, ok := tr.(interface {
                    Request() *http.Request
                }); ok {
                    httpReq = ht.Request()
                    method = httpReq.Method
                    path = httpReq.URL.Path
                }
            }

            // 2. åˆ›å»º Spanï¼ˆè¿½è¸ªå•å…ƒï¼‰
            spanName := fmt.Sprintf("%s %s %s", serviceName, method, path)
            ctx, span := otel.Tracer(serverName).Start(ctx, spanName)
            defer span.End()

            // 3. æ·»åŠ  HTTP ç›¸å…³å±æ€§
            if httpReq != nil {
                realIP := utils.GetClientIP(httpReq)

                span.SetAttributes(
                    attribute.String("http.method", httpReq.Method),
                    attribute.String("http.path", httpReq.URL.Path),
                    attribute.String("http.user_agent", httpReq.UserAgent()),
                    attribute.String("http.remote_addr", httpReq.RemoteAddr),
                    attribute.String("client.ip", realIP),
                )

                // å°†çœŸå®IPæ³¨å…¥åˆ°contextä¸­
                ctx = context.WithValue(ctx, mdx.CtxRealIP, realIP)
            }

            // 4. è®°å½•è¯·æ±‚å¼€å§‹æ—¶é—´
            span.SetAttributes(attribute.Int64("request.start_time", startTime.UnixNano()))
            ctx = context.WithValue(ctx, "start_time", startTime)

            // 5. ä¼ é€’ç”¨æˆ·ID
            if userID, ok := ctx.Value(mdx.CtxUserID).(string); ok && userID != "" {
                span.SetAttributes(attribute.String("user.id", userID))
            }

            // 6. åˆ›å»ºå¸¦è¿½è¸ªä¿¡æ¯çš„loggerå¹¶æ³¨å…¥åˆ°contextä¸­
            tracingLogger := log.CreateLoggerWithTracing(ctx)
            ctx = context.WithValue(ctx, mdx.CtxLogger, tracingLogger)

            // 7. ç»§ç»­å¤„ç†è¯·æ±‚
            reply, err = handler(ctx, req)

            // 8. è®°å½•è¯·æ±‚ç»“æœ
            duration := time.Since(startTime)
            span.SetAttributes(attribute.Int64("request.duration_ms", duration.Milliseconds()))

            if err != nil {
                span.RecordError(err)
                span.SetStatus(codes.Error, err.Error())
            } else {
                span.SetStatus(codes.Ok, "success")
            }

            return reply, err
        }
    }
}
```

---

## ğŸ“– é“¾è·¯è¿½è¸ªè¯¦è§£

### ä»€ä¹ˆæ˜¯é“¾è·¯è¿½è¸ªï¼Ÿ

**é“¾è·¯è¿½è¸ªï¼ˆTracingï¼‰** ç”¨äºè¿½è¸ªä¸€ä¸ªè¯·æ±‚åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„å®Œæ•´è·¯å¾„ã€‚

**ç¤ºä¾‹ï¼š**
```
ç”¨æˆ·è¯·æ±‚ â†’ Gateway â†’ AuthæœåŠ¡ â†’ Database
         â† Gateway â† AuthæœåŠ¡ â† Database
```

**å¥½å¤„ï¼š**
- å¿«é€Ÿå®šä½é—®é¢˜
- åˆ†ææ€§èƒ½ç“¶é¢ˆ
- äº†è§£ç³»ç»Ÿè°ƒç”¨å…³ç³»

### Spanï¼ˆè¿½è¸ªå•å…ƒï¼‰

**SpanåŒ…å«ï¼š**
- TraceIDï¼šè¿½è¸ªIDï¼ˆæ•´ä¸ªè¯·æ±‚é“¾å…±äº«ï¼‰
- SpanIDï¼šå½“å‰Spançš„ID
- å¼€å§‹æ—¶é—´ã€ç»“æŸæ—¶é—´
- æ ‡ç­¾ï¼ˆTagsï¼‰ï¼šè¯·æ±‚ä¿¡æ¯
- æ—¥å¿—ï¼ˆLogsï¼‰ï¼šå…³é”®äº‹ä»¶

---

## ğŸ“ ä¸­é—´ä»¶æœ€ä½³å®è·µ

### 1. ä¸­é—´ä»¶é¡ºåº

```go
// âœ… æ­£ç¡®çš„é¡ºåº
mws = append(mws, recovery.Recovery())      // 1. æ¢å¤ï¼ˆæœ€å¤–å±‚ï¼‰
mws = append(mws, tracing.HTTPTracingMiddleware(...))  // 2. è¿½è¸ª
mws = append(mws, jwt.JWTAuth(...))         // 3. è®¤è¯
mws = append(mws, ratelimit.RateLimit(...)) // 4. é™æµï¼ˆæœ€å†…å±‚ï¼‰
```

**ä¸ºä»€ä¹ˆè¿™ä¸ªé¡ºåºï¼Ÿ**
- Recoveryåœ¨æœ€å¤–å±‚ï¼šç¡®ä¿panicè¢«æ•è·
- Tracingåœ¨ç¬¬äºŒå±‚ï¼šè®°å½•æ‰€æœ‰è¯·æ±‚
- è®¤è¯åœ¨ç¬¬ä¸‰å±‚ï¼šåªæœ‰è®¤è¯é€šè¿‡æ‰é™æµ
- é™æµåœ¨æœ€å†…å±‚ï¼šæœ€åä¸€é“é˜²çº¿

### 2. Contextä½¿ç”¨

```go
// âœ… å¥½çš„åšæ³•ï¼šä½¿ç”¨Contextä¼ é€’ä¿¡æ¯
ctx = context.WithValue(ctx, "user_id", userID)
userID := ctx.Value("user_id").(int64)

// âŒ ä¸å¥½çš„åšæ³•ï¼šä½¿ç”¨å…¨å±€å˜é‡
globalUserID = userID  // å¹¶å‘ä¸å®‰å…¨
```

### 3. é”™è¯¯å¤„ç†

```go
// âœ… å¥½çš„åšæ³•ï¼šç»Ÿä¸€é”™è¯¯æ ¼å¼
return nil, gameErrors.New(code, message)

// âŒ ä¸å¥½çš„åšæ³•ï¼šç›´æ¥è¿”å›error
return nil, fmt.Errorf("error: %v", err)
```

---

## ğŸ’¡ å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šç†è§£ä¸­é—´ä»¶æ‰§è¡Œé¡ºåº

ç”»å‡ºè¯·æ±‚ç»è¿‡æ‰€æœ‰ä¸­é—´ä»¶çš„å®Œæ•´æµç¨‹ï¼š
```
è¯·æ±‚ â†’ [Recovery] â†’ [Tracing] â†’ [JWT] â†’ [RateLimit] â†’ ä¸šåŠ¡å¤„ç†
```

### ç»ƒä¹ 2ï¼šç¼–å†™ç®€å•ä¸­é—´ä»¶

ç¼–å†™ä¸€ä¸ªè®°å½•è¯·æ±‚è€—æ—¶çš„ä¸­é—´ä»¶ï¼š

```go
func TimingMiddleware() middleware.Middleware {
    // TODO: å®ç°è®°å½•è¯·æ±‚è€—æ—¶çš„ä¸­é—´ä»¶
}
```

### ç»ƒä¹ 3ï¼šç†è§£ç™½åå•æœºåˆ¶

æ€è€ƒä»¥ä¸‹åœºæ™¯åº”è¯¥å¦‚ä½•å¤„ç†ï¼š
- ç™»å½•æ¥å£ä¸éœ€è¦è®¤è¯
- å¥åº·æ£€æŸ¥æ¥å£ä¸éœ€è¦è®¤è¯
- é™æ€èµ„æºä¸éœ€è¦è®¤è¯

---

## ğŸ“Œ ä¸‹ä¸€é˜¶æ®µé¢„å‘Š

**é˜¶æ®µ8ï¼šJWTè®¤è¯**
- JWTåŸç†
- Tokenç”Ÿæˆå’Œè§£æ
- è®¤è¯æµç¨‹

---

## â“ æ€è€ƒé¢˜

1. ä¸ºä»€ä¹ˆä¸­é—´ä»¶è¦æŒ‰ç‰¹å®šé¡ºåºæ‰§è¡Œï¼Ÿå¦‚æœé¡ºåºé”™äº†ä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
2. ç™½åå•æœºåˆ¶çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿå¦‚ä½•è®¾è®¡ä¸€ä¸ªçµæ´»çš„ç™½åå•ç³»ç»Ÿï¼Ÿ
3. é“¾è·¯è¿½è¸ªä¸­çš„TraceIDå’ŒSpanIDæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
4. é™æµä¸­é—´ä»¶åº”è¯¥æ”¾åœ¨è®¤è¯ä¹‹å‰è¿˜æ˜¯ä¹‹åï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ

---

**å®Œæˆæœ¬é˜¶æ®µåï¼Œè¯·ç»§ç»­å­¦ä¹ é˜¶æ®µ8ï¼** ğŸš€


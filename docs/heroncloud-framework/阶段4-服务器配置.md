# é˜¶æ®µ4ï¼šæœåŠ¡å™¨é…ç½®ï¼ˆHTTP/gRPC/WebSocketï¼‰

## ğŸ“š å­¦ä¹ ç›®æ ‡
- ç†è§£HTTPæœåŠ¡å™¨çš„åˆ›å»ºå’Œé…ç½®
- æŒæ¡gRPCæœåŠ¡å™¨çš„è®¾ç½®
- å­¦ä¹ WebSocketæœåŠ¡å™¨çš„å®ç°
- ç†è§£ä¸­é—´ä»¶çš„ä½¿ç”¨

---

## ğŸŒ HTTPæœåŠ¡å™¨

### å®Œæ•´ä»£ç ï¼ˆæ‰‹å†™ç»ƒä¹ ï¼‰

```go
package server

import (
    "HeronGame/apps/gateway/internal/conf"
    ratelimit2 "HeronGame/apps/gateway/internal/data/ratelimit"
    "HeronGame/common/middleware/cors"
    errorMid "HeronGame/common/middleware/error"
    httpMid "HeronGame/common/middleware/http"
    "HeronGame/common/middleware/jwt"
    "HeronGame/common/middleware/ratelimit"
    "HeronGame/common/middleware/tracing"
    "crypto/tls"

    "github.com/go-kratos/kratos/v2/encoding"
    "github.com/go-kratos/kratos/v2/middleware"
    "github.com/go-kratos/kratos/v2/middleware/recovery"
    "github.com/go-kratos/kratos/v2/transport/http"
)

// NewHTTPServer åˆ›å»ºHTTPæœåŠ¡å™¨
func NewHTTPServer(c *conf.Bootstrap, limitManager *ratelimit2.RateLimitManager) *http.Server {
    // 1. åŸºç¡€é…ç½®é€‰é¡¹
    var opts = []http.ServerOption{
        http.Filter(cors.CORSFilter()),           // CORSè·¨åŸŸæ”¯æŒ
        http.ErrorEncoder(errorMid.ErrorsEncoder), // é”™è¯¯ç¼–ç å™¨
    }

    // 2. ç½‘ç»œé…ç½®
    if c.Server.Http.Network != "" {
        opts = append(opts, http.Network(c.Server.Http.Network))
    }
    if c.Server.Http.Addr != "" {
        opts = append(opts, http.Address(c.Server.Http.Addr))
    }
    if c.Server.Http.Timeout != nil {
        opts = append(opts, http.Timeout(c.Server.Http.Timeout.AsDuration()))
    }

    // 3. TLSé…ç½®ï¼ˆHTTPSï¼‰
    if c.Server.Http.Tls != nil && c.Server.Http.Tls.EnableTls {
        if c.Server.Http.Tls.CertFile != "" && c.Server.Http.Tls.KeyFile != "" {
            cert, err := tls.LoadX509KeyPair(c.Server.Http.Tls.CertFile, c.Server.Http.Tls.KeyFile)
            if err == nil {
                tlsConfig := &tls.Config{
                    Certificates: []tls.Certificate{cert},
                }
                opts = append(opts, http.TLSConfig(tlsConfig))
            }
        }
    }

    // 4. ä¸­é—´ä»¶é“¾
    var mws []middleware.Middleware

    // æ¢å¤ä¸­é—´ä»¶ï¼ˆæ•è·panicï¼‰
    mws = append(mws, recovery.Recovery())

    // è¿½è¸ªä¸­é—´ä»¶ï¼ˆé“¾è·¯è¿½è¸ªï¼‰
    mws = append(mws, tracing.HTTPTracingMiddleware(c.Server.Name, c.Server.Id))

    // JWTè®¤è¯ä¸­é—´ä»¶
    if c.Auth.Jwt.Enabled {
        mws = append(mws, jwt.JWTAuth(
            c.Auth.Jwt.Secret,
            c.Auth.Jwt.SigningMethod,
            c.Auth.Jwt.Whitelist,
            nil,
        ))
    }

    // é™æµä¸­é—´ä»¶
    if limitManager.GetLimiter() != nil {
        mws = append(mws, ratelimit.RateLimit(limitManager.GetLimiter()))
    }

    // 5. åº”ç”¨ä¸­é—´ä»¶
    opts = append(opts, http.Middleware(mws...))

    // 6. åˆ›å»ºHTTPæœåŠ¡å™¨
    srv := http.NewServer(opts...)

    // 7. æ³¨å†Œè‡ªå®šä¹‰ç¼–ç å™¨
    encoding.RegisterCodec(httpMid.GetCustomJSONCodec())

    return srv
}
```

---

## ğŸ“– HTTPæœåŠ¡å™¨è¯¦è§£

### 1. ServerOptionï¼ˆæœåŠ¡å™¨é€‰é¡¹ï¼‰

```go
var opts = []http.ServerOption{
    http.Filter(cors.CORSFilter()),
    http.ErrorEncoder(errorMid.ErrorsEncoder),
}
```

**çŸ¥è¯†ç‚¹ï¼š**
- `ServerOption`ï¼šå‡½æ•°å¼é€‰é¡¹æ¨¡å¼ï¼ˆFunctional Optionsï¼‰
- æ¯ä¸ªé€‰é¡¹éƒ½æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºé…ç½®æœåŠ¡å™¨
- å¯ä»¥çµæ´»ç»„åˆå¤šä¸ªé€‰é¡¹

**å‡½æ•°å¼é€‰é¡¹æ¨¡å¼çš„ä¼˜åŠ¿ï¼š**
```go
// ä¼ ç»Ÿæ–¹å¼ï¼šéœ€è¦å¾ˆå¤šå‚æ•°
NewServer(addr, timeout, tls, ...)  // å‚æ•°å¤ªå¤š

// å‡½æ•°å¼é€‰é¡¹ï¼šæ¸…æ™°çµæ´»
NewServer(
    http.Address(":8000"),
    http.Timeout(30*time.Second),
    http.TLSConfig(tlsConfig),
)
```

### 2. ç½‘ç»œé…ç½®

```go
if c.Server.Http.Network != "" {
    opts = append(opts, http.Network(c.Server.Http.Network))
}
if c.Server.Http.Addr != "" {
    opts = append(opts, http.Address(c.Server.Http.Addr))
}
```

**é…ç½®é¡¹è¯´æ˜ï¼š**
- `Network`ï¼šç½‘ç»œç±»å‹ï¼ˆtcpã€udpç­‰ï¼‰
- `Addr`ï¼šç›‘å¬åœ°å€ï¼ˆå¦‚ `:8000` æˆ– `0.0.0.0:8000`ï¼‰
- `Timeout`ï¼šè¯·æ±‚è¶…æ—¶æ—¶é—´

### 3. TLSé…ç½®ï¼ˆHTTPSï¼‰

```go
if c.Server.Http.Tls != nil && c.Server.Http.Tls.EnableTls {
    cert, err := tls.LoadX509KeyPair(c.Server.Http.Tls.CertFile, c.Server.Http.Tls.KeyFile)
    if err == nil {
        tlsConfig := &tls.Config{
            Certificates: []tls.Certificate{cert},
        }
        opts = append(opts, http.TLSConfig(tlsConfig))
    }
}
```

**çŸ¥è¯†ç‚¹ï¼š**
- `LoadX509KeyPair`ï¼šåŠ è½½è¯ä¹¦å’Œç§é’¥
- TLSç”¨äºHTTPSåŠ å¯†é€šä¿¡
- ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨HTTPS

### 4. ä¸­é—´ä»¶é“¾

```go
var mws []middleware.Middleware

// æŒ‰é¡ºåºæ·»åŠ ä¸­é—´ä»¶
mws = append(mws, recovery.Recovery())  // 1. æ¢å¤ï¼ˆæœ€å…ˆæ‰§è¡Œï¼‰
mws = append(mws, tracing.HTTPTracingMiddleware(...))  // 2. è¿½è¸ª
mws = append(mws, jwt.JWTAuth(...))  // 3. è®¤è¯
mws = append(mws, ratelimit.RateLimit(...))  // 4. é™æµï¼ˆæœ€åæ‰§è¡Œï¼‰

opts = append(opts, http.Middleware(mws...))
```

**ä¸­é—´ä»¶æ‰§è¡Œé¡ºåºï¼š**
```
è¯·æ±‚ â†’ é™æµ â†’ è®¤è¯ â†’ è¿½è¸ª â†’ æ¢å¤ â†’ ä¸šåŠ¡å¤„ç†
     â† é™æµ â† è®¤è¯ â† è¿½è¸ª â† æ¢å¤ â† å“åº”
```

**ä¸­é—´ä»¶çš„ä½œç”¨ï¼š**
- **Recovery**ï¼šæ•è·panicï¼Œé˜²æ­¢ç¨‹åºå´©æºƒ
- **Tracing**ï¼šè®°å½•è¯·æ±‚é“¾è·¯ï¼Œä¾¿äºæ’æŸ¥é—®é¢˜
- **JWT**ï¼šéªŒè¯ç”¨æˆ·èº«ä»½
- **RateLimit**ï¼šé™åˆ¶è¯·æ±‚é¢‘ç‡ï¼Œé˜²æ­¢æ”»å‡»

---

## ğŸ”Œ gRPCæœåŠ¡å™¨

### å®Œæ•´ä»£ç ï¼ˆæ‰‹å†™ç»ƒä¹ ï¼‰

```go
package server

import (
    v1 "HeronGame/api/gateway/v1/pb"
    "HeronGame/apps/gateway/internal/conf"
    "HeronGame/apps/gateway/internal/remote"
    "HeronGame/common/selector"

    "github.com/go-kratos/kratos/v2/middleware/recovery"
    "github.com/go-kratos/kratos/v2/transport/grpc"
    "github.com/nacos-group/nacos-sdk-go/clients/naming_client"
    "github.com/redis/go-redis/v9"
)

// NewGRPCServer åˆ›å»ºgRPCæœåŠ¡å™¨
func NewGRPCServer(
    bc *conf.Bootstrap,
    rdb redis.UniversalClient,
    namingClient naming_client.INamingClient,
    routerLocalCache *selector.RouterLocalCache,
    gameCommonHandler *remote.GameCommonRemoteHandler,
    chatRemoteHandler *remote.ChatRemoteHandler,
    solitaireRemoteHandler *remote.SolitaireRemoteHandler,
    minesRemoteHandler *remote.MinesRemoteHandler,
    batoRemoteHandler *remote.BatoRemoteHandler,
    tongitsRemoteHandler *remote.TongitsRemoteHandler,
    unleashRemoteHandler *remote.UnleashRemoteHandler,
) *grpc.Server {
    c := bc.Server.Grpc

    // 1. åˆå§‹åŒ–å…¨å±€è´Ÿè½½å‡è¡¡å™¨
    selector.InitGlobalLoadBalancer(rdb, namingClient, routerLocalCache)

    // 2. é…ç½®é€‰é¡¹
    var opts = []grpc.ServerOption{
        grpc.Middleware(recovery.Recovery()),  // æ¢å¤ä¸­é—´ä»¶
    }
    
    if c.Network != "" {
        opts = append(opts, grpc.Network(c.Network))
    }
    if c.Addr != "" {
        opts = append(opts, grpc.Address(c.Addr))
    }
    if c.Timeout != nil {
        opts = append(opts, grpc.Timeout(c.Timeout.AsDuration()))
    }

    // 3. åˆ›å»ºgRPCæœåŠ¡å™¨
    srv := grpc.NewServer(opts...)

    // 4. æ³¨å†ŒæœåŠ¡å¤„ç†å™¨
    v1.RegisterChatRemoteServer(srv, chatRemoteHandler)
    v1.RegisterSolitaireRemoteServer(srv, solitaireRemoteHandler)
    v1.RegisterMinesRemoteServer(srv, minesRemoteHandler)
    v1.RegisterGameCommonRemoteServer(srv, gameCommonHandler)
    v1.RegisterBatoRemoteServer(srv, batoRemoteHandler)
    v1.RegisterTongitsRemoteServer(srv, tongitsRemoteHandler)
    v1.RegisterUnleashRemoteServer(srv, unleashRemoteHandler)

    return srv
}
```

---

## ğŸ“– gRPCæœåŠ¡å™¨è¯¦è§£

### 1. ä»€ä¹ˆæ˜¯gRPCï¼Ÿ

**gRPCç‰¹ç‚¹ï¼š**
- é«˜æ€§èƒ½ï¼šåŸºäºHTTP/2ï¼Œæ”¯æŒæµå¼ä¼ è¾“
- è·¨è¯­è¨€ï¼šä½¿ç”¨Protobufå®šä¹‰æ¥å£
- ç±»å‹å®‰å…¨ï¼šç¼–è¯‘æ—¶æ£€æŸ¥ç±»å‹

**ä¸HTTP RESTçš„åŒºåˆ«ï¼š**
```
HTTP REST:
  å®¢æˆ·ç«¯ â†’ JSON â†’ HTTP â†’ æœåŠ¡å™¨
  æœåŠ¡å™¨ â†’ JSON â†’ HTTP â†’ å®¢æˆ·ç«¯

gRPC:
  å®¢æˆ·ç«¯ â†’ Protobuf â†’ HTTP/2 â†’ æœåŠ¡å™¨
  æœåŠ¡å™¨ â†’ Protobuf â†’ HTTP/2 â†’ å®¢æˆ·ç«¯
```

### 2. æœåŠ¡æ³¨å†Œ

```go
// æ³¨å†ŒæœåŠ¡å¤„ç†å™¨
v1.RegisterChatRemoteServer(srv, chatRemoteHandler)
v1.RegisterSolitaireRemoteServer(srv, solitaireRemoteHandler)
```

**çŸ¥è¯†ç‚¹ï¼š**
- `RegisterChatRemoteServer`ï¼šç”±Protobufè‡ªåŠ¨ç”Ÿæˆ
- ç¬¬ä¸€ä¸ªå‚æ•°ï¼šgRPCæœåŠ¡å™¨
- ç¬¬äºŒä¸ªå‚æ•°ï¼šæœåŠ¡å®ç°ï¼ˆHandlerï¼‰

### 3. è´Ÿè½½å‡è¡¡

```go
selector.InitGlobalLoadBalancer(rdb, namingClient, routerLocalCache)
```

**ä½œç”¨ï¼š**
- å°†è¯·æ±‚è·¯ç”±åˆ°åˆé€‚çš„æœåŠ¡å®ä¾‹
- æ”¯æŒä¸€è‡´æ€§å“ˆå¸Œï¼ˆç›¸åŒæˆ¿é—´è·¯ç”±åˆ°åŒä¸€å®ä¾‹ï¼‰
- ä½¿ç”¨Rediså­˜å‚¨è·¯ç”±ä¿¡æ¯

---

## ğŸ”„ WebSocketæœåŠ¡å™¨

### æ ¸å¿ƒä»£ç ç»“æ„

```go
package server

import (
    "HeronGame/apps/gateway/internal/conf"
    "HeronGame/apps/gateway/internal/handler"
    "HeronGame/apps/gateway/internal/manager"
    "context"
    "net/http"
    "time"

    "github.com/go-kratos/kratos/contrib/registry/nacos/v2"
    "github.com/go-kratos/kratos/v2/registry"
    "github.com/go-kratos/kratos/v2/transport"
    "github.com/gorilla/websocket"
    "github.com/redis/go-redis/v9"
)

// WebSocketServer WebSocketæœåŠ¡å™¨
type WebSocketServer struct {
    config   *conf.Bootstrap
    upgrader websocket.Upgrader
    server   *http.Server
    rdb      redis.UniversalClient

    // ç®¡ç†å™¨
    connectionManager *manager.ConnectionManager
    messageHandler    *handler.MessageHandler

    // æœåŠ¡æ³¨å†Œ
    registry *nacos.Registry
    instance *registry.ServiceInstance
}

// NewWebSocketServer åˆ›å»ºWebSocketæœåŠ¡å™¨
func NewWebSocketServer(
    c *conf.Bootstrap,
    messageHandler *handler.MessageHandler,
    connectionManager *manager.ConnectionManager,
    rdb redis.UniversalClient,
    serverRegistry *nacos.Registry,
) *WebSocketServer {
    // 1. é…ç½®Upgrader
    upgrader := websocket.Upgrader{
        ReadBufferSize:  int(c.Server.Websocket.ReadBufferSize),
        WriteBufferSize: int(c.Server.Websocket.WriteBufferSize),
        CheckOrigin: func(r *http.Request) bool {
            return !c.Server.Websocket.CheckOrigin
        },
    }

    // 2. æ„å»ºæœåŠ¡å®ä¾‹ä¿¡æ¯
    instance := &registry.ServiceInstance{
        ID:      c.Server.Id,
        Name:    c.Server.Name,
        Version: c.Server.Version,
        Metadata: map[string]string{
            "kind":        "websocket",
            "instance_id": c.Server.Id,
            "client_addr": c.Server.Websocket.ClientWsAddr,
        },
        Endpoints: []string{
            fmt.Sprintf("%s://%s/ws", c.Server.Websocket.Network, c.Server.Websocket.Addr),
        },
    }

    // 3. åˆ›å»ºWebSocketæœåŠ¡å™¨
    ws := &WebSocketServer{
        config:            c,
        upgrader:          upgrader,
        connectionManager: connectionManager,
        messageHandler:    messageHandler,
        rdb:               rdb,
        registry:          serverRegistry,
        instance:          instance,
    }

    // 4. åˆ›å»ºHTTPæœåŠ¡å™¨ç”¨äºWebSocketå‡çº§
    mux := http.NewServeMux()
    mux.HandleFunc("/ws", ws.handleWebSocket)

    ws.server = &http.Server{
        Addr:    c.Server.Websocket.Addr,
        Handler: mux,
        ReadTimeout: func() time.Duration {
            if c.Server.Websocket.Timeout != nil {
                return c.Server.Websocket.Timeout.AsDuration()
            }
            return 30 * time.Second
        }(),
        WriteTimeout: func() time.Duration {
            if c.Server.Websocket.Timeout != nil {
                return c.Server.Websocket.Timeout.AsDuration()
            }
            return 30 * time.Second
        }(),
    }

    return ws
}

// Start å¯åŠ¨WebSocketæœåŠ¡å™¨
func (ws *WebSocketServer) Start(ctx context.Context) error {
    log.Info(ctx, "[gateway] WebSocket æœåŠ¡å™¨å¯åŠ¨ "+ws.config.Server.Websocket.Addr)
    return ws.server.ListenAndServe()
}

// Stop åœæ­¢WebSocketæœåŠ¡å™¨
func (ws *WebSocketServer) Stop(ctx context.Context) error {
    log.Info(ctx, "[gateway] æ­£åœ¨åœæ­¢ WebSocket æœåŠ¡å™¨")
    return ws.server.Shutdown(ctx)
}
```

---

## ğŸ“– WebSocketè¯¦è§£

### 1. WebSocket vs HTTP

**HTTPï¼š**
- è¯·æ±‚-å“åº”æ¨¡å¼
- å®¢æˆ·ç«¯å‘èµ·è¯·æ±‚ï¼ŒæœåŠ¡å™¨å“åº”
- æ— æ³•ä¸»åŠ¨æ¨é€æ¶ˆæ¯ç»™å®¢æˆ·ç«¯

**WebSocketï¼š**
- å…¨åŒå·¥é€šä¿¡
- å»ºç«‹è¿æ¥åï¼ŒåŒæ–¹éƒ½å¯ä»¥ä¸»åŠ¨å‘é€æ¶ˆæ¯
- é€‚åˆå®æ—¶é€šä¿¡ï¼ˆèŠå¤©ã€æ¸¸æˆç­‰ï¼‰

### 2. Upgraderï¼ˆå‡çº§å™¨ï¼‰

```go
upgrader := websocket.Upgrader{
    ReadBufferSize:  4096,   // è¯»ç¼“å†²åŒºå¤§å°
    WriteBufferSize: 4096,   // å†™ç¼“å†²åŒºå¤§å°
    CheckOrigin: func(r *http.Request) bool {
        return !c.Server.Websocket.CheckOrigin  // æ˜¯å¦æ£€æŸ¥Origin
    },
}
```

**ä½œç”¨ï¼š**
- å°†HTTPè¿æ¥å‡çº§ä¸ºWebSocketè¿æ¥
- `CheckOrigin`ï¼šæ£€æŸ¥è¯·æ±‚æ¥æºï¼Œé˜²æ­¢è·¨ç«™æ”»å‡»

### 3. è¿æ¥å¤„ç†æµç¨‹

```
1. å®¢æˆ·ç«¯å‘èµ·HTTPè¯·æ±‚ï¼ˆå¸¦Upgradeå¤´ï¼‰
   â†“
2. æœåŠ¡å™¨è°ƒç”¨Upgrader.Upgrade()å‡çº§è¿æ¥
   â†“
3. è¿›è¡ŒJWTè®¤è¯
   â†“
4. åˆ›å»ºConnectionå¯¹è±¡
   â†“
5. è¿›å…¥æ¶ˆæ¯å¾ªç¯ï¼ˆè¯»å–å’Œå‘é€æ¶ˆæ¯ï¼‰
```

---

## ğŸ“ æœåŠ¡å™¨å¯¹æ¯”

| ç‰¹æ€§ | HTTP | gRPC | WebSocket |
|------|------|------|-----------|
| åè®® | HTTP/1.1 | HTTP/2 | WebSocket |
| æ•°æ®æ ¼å¼ | JSON | Protobuf | äºŒè¿›åˆ¶ |
| é€šä¿¡æ–¹å¼ | è¯·æ±‚-å“åº” | è¯·æ±‚-å“åº”/æµ | å…¨åŒå·¥ |
| é€‚ç”¨åœºæ™¯ | REST API | å¾®æœåŠ¡é—´é€šä¿¡ | å®æ—¶é€šä¿¡ |
| æ€§èƒ½ | ä¸­ç­‰ | é«˜ | é«˜ |

---

## ğŸ’¡ å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šç†è§£ä¸­é—´ä»¶æ‰§è¡Œé¡ºåº

ç”»å‡ºHTTPè¯·æ±‚ç»è¿‡ä¸­é—´ä»¶çš„å®Œæ•´æµç¨‹ï¼š
```
è¯·æ±‚ â†’ [é™æµ] â†’ [è®¤è¯] â†’ [è¿½è¸ª] â†’ [æ¢å¤] â†’ ä¸šåŠ¡å¤„ç† â†’ å“åº”
```

### ç»ƒä¹ 2ï¼šæ‰‹å†™æœåŠ¡å™¨åˆ›å»ºä»£ç 

å°è¯•æ‰‹å†™ä¸€ä¸ªç®€å•çš„HTTPæœåŠ¡å™¨åˆ›å»ºå‡½æ•°ï¼š

```go
func NewSimpleHTTPServer(addr string) *http.Server {
    // TODO: å®ç°åˆ›å»ºé€»è¾‘
}
```

### ç»ƒä¹ 3ï¼šç†è§£WebSocketå‡çº§è¿‡ç¨‹

1. å®¢æˆ·ç«¯å¦‚ä½•å‘èµ·WebSocketè¿æ¥ï¼Ÿ
2. æœåŠ¡å™¨å¦‚ä½•å‡çº§HTTPè¿æ¥ï¼Ÿ
3. å‡çº§åå¦‚ä½•ä¿æŒè¿æ¥ï¼Ÿ

---

## ğŸ“Œ ä¸‹ä¸€é˜¶æ®µé¢„å‘Š

**é˜¶æ®µ5ï¼šæ—¥å¿—ç³»ç»Ÿ**
- å­¦ä¹ Zapæ—¥å¿—åº“çš„ä½¿ç”¨
- ç†è§£æ—¥å¿—çº§åˆ«å’Œæ ¼å¼
- æŒæ¡æ—¥å¿—è½®è½¬å’Œæ–‡ä»¶ç®¡ç†

---

## â“ æ€è€ƒé¢˜

1. ä¸ºä»€ä¹ˆHTTPæœåŠ¡å™¨éœ€è¦å¤šä¸ªä¸­é—´ä»¶ï¼Ÿå®ƒä»¬çš„æ‰§è¡Œé¡ºåºä¸ºä»€ä¹ˆé‡è¦ï¼Ÿ
2. gRPCå’ŒHTTP REST APIå„æœ‰ä»€ä¹ˆä¼˜ç¼ºç‚¹ï¼Ÿä»€ä¹ˆæ—¶å€™ç”¨å“ªä¸ªï¼Ÿ
3. WebSocketè¿æ¥å»ºç«‹åï¼Œå¦‚ä½•æ£€æµ‹è¿æ¥æ˜¯å¦æ–­å¼€ï¼Ÿ
4. ä¸ºä»€ä¹ˆWebSocketæœåŠ¡å™¨éœ€è¦æ³¨å†Œåˆ°æœåŠ¡å‘ç°ï¼ˆNacosï¼‰ï¼Ÿ

---

**å®Œæˆæœ¬é˜¶æ®µåï¼Œè¯·ç»§ç»­å­¦ä¹ é˜¶æ®µ5ï¼** ğŸš€

